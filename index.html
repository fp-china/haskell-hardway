<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0061)http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="keywords" content="Haskell, programming, functional, tutorial">
        <link rel="shortcut icon" type="image/x-icon" href="http://yannesposito.com/Scratch/img/favicon.ico">
        <link rel="stylesheet" type="text/css" href="./Learn Haskell Fast and Hard_files/main.css">
        <link rel="stylesheet" type="text/css" href="./Learn Haskell Fast and Hard_files/solarized.css">
        <link rel="stylesheet" type="text/css" href="./Learn Haskell Fast and Hard_files/idc.css">
        <link href="./Learn Haskell Fast and Hard_files/css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/rss+xml" title="RSS" href="http://feeds.feedburner.com/yannespositocomen">
        <title>Learn Haskell Fast and Hard</title>
</head>
    <body lang="en" class="article" data-twttr-rendered="true">
        <div id="content">
            <div id="titre">
                <h1>
                    Learn Haskell Fast and Hard
                </h1>
                <h2>
                    用 Haskell 开阔你的视野
                </h2>
            </div>

            <div id="afterheader">
                <div class="corps">
                    <p><img alt="Magritte pleasure principle" src="./Learn Haskell Fast and Hard_files/magritte_pleasure_principle.jpg"></p>
<div class="intro">
<p><span class="sc"><abbr title="Too long; didn&#39;t read">长文</abbr>: </span> 这是一份浓缩过的 Haskell 教程.</p>

<blockquote><center><hr style="width:30%;float:left;border-color:#CCCCD0;margin-top:1em">
<span class="sc"><b>目录</b></span>
<hr style="width:30%;float:right;border-color:#CCCCD0;margin-top:1em"></center>
<div class="toc">
  <ul>
    <li><a href="#introduction">介绍</a>
      <ul>
        <li><a href="#install">安装</a></li>
        <li><a href="#don-t-be-afraid">别担心</a></li>
        <li><a href="#very-basic-haskell">基础的 Haskell</a>
          <ul>
            <li><a href="#function-declaration">函数声明</a></li>
            <li><a href="#a-type-example">类型的例子</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#essential-haskell">Haskell 要点</a>
      <ul>
        <li><a href="#notations">记法</a>
          <ul>
            <li><a href="#arithmetic">算术</a></li>
            <li><a href="#logic">逻辑</a></li>
            <li><a href="#powers">Powers</a></li>
            <li><a href="#lists">Lists</a></li>
            <li><a href="#strings">Strings</a></li>
            <li><a href="#tuples">Tuples</a></li>
            <li><a href="#deal-with-parentheses">处理圆括号</a></li>
          </ul>
        </li>
        <li><a href="#useful-notations-for-functions">常用函数记法</a></li>
      </ul>
    </li>
    <li><a href="#hard-part">难点</a>
      <ul>
        <li><a href="#functional-style">函数风格</a>
          <ul>
            <li><a href="#higher-order-functions">高阶函数</a></li>
          </ul>
        </li>
        <li><a href="#types">类型</a>
          <ul>
            <li><a href="#type-inference">类型推断</a></li>
            <li><a href="#type-construction">类型构造</a></li>
            <li><a href="#recursive-type">递归类型</a></li>
            <li><a href="#trees">Trees</a></li>
          </ul>
        </li>
        <li><a href="#infinite-structures">无限结构</a></li>
      </ul>
    </li>
    <li><a href="#hell-difficulty-part">超难的地方</a>
      <ul>
        <li><a href="#deal-with-io">处理 IO</a></li>
        <li><a href="#io-trick-explained">IO 手法解析</a></li>
        <li><a href="#monads">Monads</a>
          <ul>
            <li><a href="#maybe-monad">Maybe 是 monad</a></li>
            <li><a href="#the-list-monad">List monad</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#appendix">附录</a>
      <ul>
        <li><a href="#more-on-infinite-tree">更多关于 Infinite Tree</a></li>
      </ul>
    </li>
  </ul>
</div>
</blockquote>
</div>
<div class="intro">

<p>我坚信所有开发者的都该来学 Haskell.
我不认为所有人应该成为 Haskell 的超级忍者,
但至少, 他们能发现 Haskell 的存在提供些什么.
学习 Haskell 打开你的思维.</p>

<p>主流语言共通的基础:</p>

<ul>
  <li>变量</li>
  <li>循环</li>
  <li>指针<sup id="fnref:0001"><a href="#fn:0001" rel="footnote">1</a></sup></li>
  <li>数据类型, 对象和类(对于大多数)</li>
</ul>

<p>Haskell 非常特别.
这门语言应用了很多我从未听说的概念.
其中很多会助你成为更好的程序员.</p>

<p>然而, 学习 Haskell 可能很难.
对我就这样.
在这篇文章, 我尝试提供我学习过程中所认为缺少的.</p>

<p>这篇文章的进度会很难被跟上.
这是有意为之的.
世上没有学习 Haskell 的捷径.
只有难题和挑战.
但我相信这是一件好事.
因为 Haskell 很难, 所以她会很有趣.</p>

<p>学 Haskell 的常规办法是的看两本书.
第一本 <a href="http://learnyouahaskell.com/">“Learn You a Haskell”</a> 接着是
<a href="http://www.realworldhaskell.org/">“Real World Haskell”</a>.
我也相信这是正确的途径/
但是, 为了学会所有 Haskell 索要表达的, 你需要阅读全部的细节.</p>

<p>同时, 本文对 Haskell 各个方面一个简短和浓缩的概览.
我还加了我学习 Haskell 时我所缺少的资源.

<p>本文包括五个部分:</p>

<ul>
  <li>介绍: 一个简短的例子来表明 Haskell 的友好性.</li>
  <li>基础的 Haskell: Haskell 语法, 和一些必需的记法.</li>
  <li>难点:
    <ul>
      <li>函数风格; 一个渐进的例子, 从命令式到函数式风格</li>
      <li>类型; 类型和标准 binary tree 的例子</li>
      <li>无穷类型; 操作一个 infinite binary tree!</li>
    </ul>
  </li>
  <li>超难的地方
    <ul>
      <li>处理 IO; 一个很迷你的例子</li>
      <li>IO 手法解析; 我理解 IO 所缺失的隐藏细节</li>
      <li>Monads; 难以置信我们能怎样生成</li>
    </ul>
  </li>
  <li>附录:
    <ul>
      <li>更多关于 infinite tree; 关于 infinite trees 更数学化的讨论</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>注: 每次你都会看到一个文件后缀为 <code>.lhs</code> 的分隔,
你可以点击文件名下载这些文件.
如果你把文件存为<code>filename.lhs</code>, 你可以运行之 </p>
  <pre>runhaskell filename.lhs
</pre>

  <p>某些大概不能运行, 但绝大多数该可以.
你应该能看到这下面有个链接.</p>
</blockquote>


</div>


<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/00_hello_world.lhs" class="cut">01_basic/10_Introduction/<strong>00_hello_world.lhs</strong></a></p>

<h2 id="introduction">介绍</h2>

<h3 id="install">安装</h3>

<p><img alt="Haskell logo" src="./Learn Haskell Fast and Hard_files/Haskell-logo.png"></p>

<ul>
  <li><a href="http://www.haskell.org/platform">Haskell Platform</a> 是安装 Haskell 的标准方法..</li>
</ul>

<p>工具:</p>

<ul>
  <li><code>ghc</code>: 编译器, 类似于对 <code>C</code> 而言的 gcc.</li>
  <li><code>ghci</code>: 交互式的 Haskell (REPL)</li>
  <li><code>runhaskell</code>: 不编译而直接运行 Haskell 程序. 方便, 但对比经过编译的程序显得很慢.</li>
</ul>

<h3 id="don-t-be-afraid">别担心</h3>

<p><img alt="The Scream" src="./Learn Haskell Fast and Hard_files/munch_TheScream.jpg"></p>

<p>很多 Haskell 的书籍文章一开始的介绍用的是那些深奥的程序(快速排序, Fibonacci, 等等...).
我想做的恰恰相反.
首先我不会给你看任何 Haskell 的超能力.
我会从 Haskell 与其他编程语言之间的相似点开始.
让我们开始看惯例的 "Hello World".</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = putStrLn <span class="string">"Hello World!"</span>
</code></pre>


</div>
<p>要运行的话, 可以把代码存为 <code>hello.hs</code> 然后执行:</p>

<pre><code class="zsh avrasm">~ runhaskell ./hello<span class="preprocessor">.hs</span> Hello World!
</code></pre>

<p>你也可以下载这份文本的 Haskell 代码.
你应该能看到标题"介绍"上方有个链接.
把文件下载保存为 <code>00_hello_world.lhs</code> 然后执行:</p>

<pre><code class="zsh markdown">~ runhaskell 00<span class="emphasis">_hello_</span>world.lhs
Hello World!
</code></pre>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/00_hello_world.lhs" class="cut">01_basic/10_Introduction/<strong>00_hello_world.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/10_hello_you.lhs" class="cut">01_basic/10_Introduction/<strong>10_hello_you.lhs</strong></a></p>

<p>现在, 一个询问你姓名并根据你输入的姓名回答"Hello"的程序:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = <span class="keyword">do</span>
    print <span class="string">"What is your name?"</span>
    name &lt;- getLine
    print (<span class="string">"Hello "</span> ++ name ++ <span class="string">"!"</span>)
</code></pre>


</div>
<p>首先, 让我们跟一些命令式语言写的类似程序对比:</p>

<pre><code class="python"> <span class="comment"># Python</span>
<span class="keyword">print</span> <span class="string">"What is your name?"</span>
name = raw_input()
<span class="keyword">print</span> <span class="string">"Hello %s!"</span> % name
</code></pre>

<pre><code class="ruby"> <span class="comment"># Ruby</span>
<span class="identifier"><span class="keymethods">puts</span></span> <span class="string">"What is your name?"</span>
<span class="identifier"><span class="keymethods">name</span></span> = <span class="identifier"><span class="keymethods">gets</span></span>.<span class="identifier"><span class="keymethods">chomp</span></span>
<span class="identifier"><span class="keymethods">puts</span></span> <span class="string">"Hello <span class="subst">#{<span class="identifier"><span class="keymethods">name</span></span>}</span>!"</span>
</code></pre>

<pre><code class="c tex">// In C
 <span class="special">#</span>include &lt;stdio.h&gt;
int main (int argc, char **argv) <span class="special">{</span>
    char name<span class="special">[</span>666<span class="special">]</span>; // &lt;- An Evil Number!
    // What if my name is more than 665 character long?
    printf("What is your name?<span class="command">\n</span>");
    scanf("<span class="comment">%s", name);</span>
    printf("Hello <span class="comment">%s!\n", name);</span>
    return 0;
<span class="special">}</span>
</code></pre>

<p>结构是一样的, 但有些语法差异.
这分教程主体部分会专门用来解释原因.</p>

<p>Haskell 里有个<code>main</code> 函数, 然后每个对象有它的类型.
<code>main</code> 的类型是 <code>IO ()</code>.
意味着, <code>main</code> 将引起副作用.</p>

<p>反正记住 Haskell 可以更像主流命令式语言.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/10_hello_you.lhs" class="cut">01_basic/10_Introduction/<strong>10_hello_you.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/20_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>20_very_basic.lhs</strong></a></p>

<h3 id="very-basic-haskell">基础的 Haskell</h3>

<p><img alt="Picasso minimal owl" src="./Learn Haskell Fast and Hard_files/picasso_owl.jpg"></p>

<p>继续文章之前你需要注意 Haskell 一些本质的属性.</p>

<p><em>函数式</em></p>

<p>Haskell 是一门函数式语言.
如果你有命令式语言背景, 那你会有很多需要学的.
希望其中很多心概念甚至能在命令式编程里帮到你.

<p><em>自动静态类型</em></p>

<p>不像<code>C</code>, <code>C++</code> or <code>Java</code>里那个样子, 类型系统这里使用来帮助你的.</p>

<p><em>纯</em></p>

<p>一般来说你的函数不会修改任何外部的内容.
就是用, 她无法修改变量的值, 不能获取用户输入, 不能读取屏幕字符, 不能发射火箭.
另一面, 并行计算是很容易实现的.
Haskell 理清了哪里副作用将出现以及哪里你是纯的.
同时, 难懂你的程序将会容易非常多.
纯的部分程序很多 bug 都被预防掉了.

<p>而且纯函数遵循着 Haskell 的基本定律.

<blockquote>
  <p>用相同的参数调用相同的函数往往有相同的返回值.</p>
</blockquote>

<p><em>惰性</em></p>

<p>默认的惰性是种很不寻常的语言设计.
默认情况下, Haskell 只有在必要是才进行求值.
一种结果是, 她提供给常优雅的方式来处理无限结构.

<p>最后一个关于你该怎样阅读 Haskell 代码的注意点.
对我, 那就像阅读科学文献.
一些部分很清晰, 但等你看到个公式, 就要集中精神慢慢读.
同时, 学习 Haskell, 你不懂语法的细节真的不很重要.

如果你遇到 <code>&gt;&gt;=</code>, <code>&lt;$&gt;</code>, <code>&lt;-</code> 或者其他古怪的符号, 干脆跳过去看代码的流程.</p>

<h4 id="function-declaration">函数声明</h4>

<p>你大概习惯这样声明函数</p>

<p>In <code>C</code>:</p>

<pre><code class="c perl"><span class="keyword">int</span> f(<span class="keyword">int</span> <span class="keyword">x</span>, <span class="keyword">int</span> <span class="keyword">y</span>) {
    <span class="keyword">return</span> <span class="keyword">x</span><span class="variable">*x</span> + <span class="keyword">y</span><span class="variable">*y</span>;
}
</code></pre>

<p>In Javascript:</p>

<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x,y)</span> {</span>
    <span class="keyword">return</span> x*x + y*y;
}
</code></pre>

<p>in Python:</p>

<pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span>
    <span class="keyword">return</span> x*x + y*y
</code></pre>

<p>in Ruby:</p>

<pre><code class="ruby"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(<span class="identifier">x</span>,<span class="identifier">y</span>)</span></span>
    <span class="identifier">x</span>*<span class="identifier">x</span> + <span class="identifier">y</span>*<span class="identifier">y</span>
<span class="identifier"><span class="keyword">end</span></span>
</code></pre>

<p>In Scheme:</p>

<pre><code class="scheme lisp"><span class="list">(<span class="title">define</span><span class="body"> <span class="list">(<span class="title">f</span><span class="body"> x y</span>)</span>
    <span class="list">(<span class="title">+</span><span class="body"> <span class="list">(<span class="title">*</span><span class="body"> x x</span>)</span> <span class="list">(<span class="title">*</span><span class="body"> y y</span>)</span></span>)</span></span>)</span>
</code></pre>

<p>最后, Haskell 的方式:</p>

<pre><code class="haskell"><span class="title">f</span> x y = x*x + y*y
</code></pre>

<p>很干净. 没括号, 没 <code>def</code>.</p>

<p>记住, Haskell 经常用到函数和类型.
就这样定义它们非常简单.
语法为了这些对象专门考虑的.

<h4 id="a-type-example">类型的例子</h4>

<p>通常的办法是声明你函数的类型.
这不是非有不可的.
编译器足够聪明去替你给出类型.</p>

<p>Let’s play a little.</p>
<p>我们写写看.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- We declare the type using ::</span>
<span class="title">f</span> :: <span class="label">Int</span> -&gt; <span class="label">Int</span> -&gt; <span class="label">Int</span>
<span class="title">f</span> x y = x*x + y*y

<span class="title">main</span> = print (f <span class="number">2</span> <span class="number">3</span>)
</code></pre>


</div>
<pre><code class="markdown">~ runhaskell 20<span class="emphasis">_very_</span>basic.lhs
13
</code></pre>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/20_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>20_very_basic.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/21_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>21_very_basic.lhs</strong></a></p>

<p>再试试</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">f</span> :: <span class="label">Int</span> -&gt; <span class="label">Int</span> -&gt; <span class="label">Int</span>
<span class="title">f</span> x y = x*x + y*y

<span class="title">main</span> = print (f <span class="number">2.3</span> <span class="number">4.2</span>)
</code></pre>


</div>
<p>你看到这个报错:</p>

<pre><code class="vbscript"><span class="number">21</span>_very_basic.lhs:<span class="number">6</span>:<span class="number">23</span>:
    No instance <span class="keyword">for</span> (Fractional <span class="built_in">Int</span>)
      arising from the literal `<span class="number">4.2</span><span class="comment">'</span>
    Possible fix: add an instance declaration <span class="keyword">for</span> (Fractional <span class="built_in">Int</span>)
    <span class="keyword">In</span> the <span class="built_in">second</span> argument of `f<span class="comment">', namely `4.2'</span>
    <span class="keyword">In</span> the first argument of `print<span class="comment">', namely `(f 2.3 4.2)'</span>
    <span class="keyword">In</span> the expression: print (f <span class="number">2.3</span> <span class="number">4.2</span>)
</code></pre>

<p>问题: <code>4.2</code> 不属于 Int.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/21_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>21_very_basic.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/22_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>22_very_basic.lhs</strong></a></p>

<p>解决方案,
别声明 <code>f</code> 的类型.
Haskell 会为我们推断出尽可能通用的类型:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">f</span> x y = x*x + y*y

<span class="title">main</span> = print (f <span class="number">2.3</span> <span class="number">4.2</span>)
</code></pre>


</div>
<p>运行成功.
好, 我们不需要声明新函数的每个类型.
比如, 用 <code>C</code>, 你得声明函数为<code>int</code>, 为 <code>float</code>, 为 <code>long</code>, 为 <code>double</code>, 等等...</p>

<p>但是, 我们该怎么去声明类型?
要看 Haskell 推出来的类型, 得运行 ghci:</p>

<pre><span class="low">
%</span> ghci<span class="low"><code>
GHCi, version 7.0.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Prelude&gt;</code></span> let f x y = x*x + y*y
<span class="low"><code>Prelude&gt;</code></span> :type f
<code>f :: Num a =&gt; a -&gt; a -&gt; a</code>
</pre>

<p>呃? 这个古怪的类型什么意思?</p>

<pre><code class="perl">Num <span class="string">a =&gt;</span> a -&gt; a -&gt; a
</code></pre>

<p>首先, 仔细看右边的部分 <code>a -&gt; a -&gt; a</code>.
为了理解, 来看一列步进的例子:</p>

<table>
  <tbody>
    <tr>
      <td>类型的写法</td>
      <td>意义</td>
    </tr>
    <tr>
      <td><code>Int</code></td>
      <td><code>Int</code>类型</td>
    </tr>
    <tr>
      <td><code>Int -&gt; Int</code></td>
      <td>类型由 <code>Int</code> 到 <code>Int</code> 的函数 </td>
    </tr>
    <tr>
      <td><code>Float -&gt; Int</code></td>
      <td>类型由 <code>Float</code> 到 <code>Int</code> 的函数</td>
    </tr>
    <tr>
      <td><code>a -&gt; Int</code></td>
      <td>任意类型到 <code>Int</code> 的函数</td>
    </tr>
    <tr>
      <td><code>a -&gt; a</code></td>
      <td>类型由某个 <code>a</code> 到同个 <code>a</code> 的函数 </td>
    </tr>
    <tr>
      <td><code>a -&gt; a -&gt; a</code></td>
      <td>接收两个参数类型 <code>a</code> 返回 <code>a</code> 类型的函数</td>
    </tr>
  </tbody>
</table>

<p>在类型 <code>a -&gt; a -&gt; a</code> 里, 字母 <code>a</code> 是个 <em>类型变量</em>.
意思是<code>f</code> 是有两个参数的函数而且两个参数和返回值是相同的类型.
类型变量 <code>a</code> 能表示多种类型.
比如 <code>Int</code>, <code>Integer</code>, <code>Float</code>...</p>

<p>所以不像强制类型的 <code>C</code> 声明函数为 <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, 等等...
我们定义函数就像是动态语言.</p>

<p>通常 <code>a</code> 能是任意类型.
比如 <code>String</code>, <code>Int</code>, 也有更复杂的类型, 像 <code>Trees</code>, 其他的函数, 等等...
不过这里我们的类型加了前缀 <code>Num a =&gt; </code>. </p>

<p><code>Num</code> 是个 <em>类型类</em>.
类型类可以理解为一些类型的集合.
<code>Num</code> 仅包含表现为数字的几个类型.
更简单说, <code>Num</code> 类中的类型能运行一套特定的函数, 尤其是 <code>(+)</code> 和 <code>(*)</code>.</p>

<p>类型类是很强大的语言构建.
这能被用来做一些特别强大的事.
后面会再细说.</p>

<p>最后, <code>Num a =&gt; a -&gt; a -&gt; a</code> 是说:</p>

<p>用 <code>a</code> 表示一个属于 <code>Num</code> 类型类的类型.
这是个类型由 <code>a</code> 到 (<code>a -&gt; a</code>) 的函数.</p>

<p>是的, 怪.
事实上 Haskell 没一个函数真有两个参数.
反而所有函数都只有一个参数.
但我们会发现接收两个参数等同于接收一个参数再返回一个来接收第二个参数的函数.</p>

<p>更直白地 <code>f 3 4</code> 等于是 <code>(f 3) 4</code>.
注意 <code>f 3</code> 是个函数:</p>

<pre><code class="perl">f :: Num a :: a -&gt; a -&gt; a

g :: Num a :: a -&gt; a
g = f <span class="number">3</span>

g <span class="keyword">y</span> ⇔ <span class="number">3</span><span class="variable">*3</span> + <span class="keyword">y</span><span class="variable">*y</span>
</code></pre>

<p>函数有另一个记法.
lambda 记法让我们能创建函数而不带函数名.
称为匿名函数.
像这样写:</p>

<pre><code class="tex">g = <span class="command">\y</span> -&gt; 3*3 + y*y
</code></pre>

<p>用 <code>\</code> 是因为它像 <code>λ</code> 而且属于 ASCII.</p>

<p>如果你没习惯函数式编程, 你的脑子该开始热了.
可以去做真实应用了.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/22_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>22_very_basic.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/23_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>23_very_basic.lhs</strong></a></p>

<p>但那之前, 我们要确认下类型系统能像预期那样运行:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">f</span> :: <span class="label">Num</span> a =&gt; a -&gt; a -&gt; a
<span class="title">f</span> x y = x*x + y*y

<span class="title">main</span> = print (f <span class="number">3</span> <span class="number">2.4</span>)
</code></pre>


</div>
<p>运行正常, 因为, <code>3</code> 同时是 Float 和 Integer 合法的分数写法.
因为 <code>2.4</code> 是分数, <code>3</code> 也就作为分数解释.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/23_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>23_very_basic.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/24_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>24_very_basic.lhs</strong></a></p>

<p>如果强制让函数接收两个不同的类型, 运行会出错:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">f</span> :: <span class="label">Num</span> a =&gt; a -&gt; a -&gt; a
<span class="title">f</span> x y = x*x + y*y

<span class="title">x</span> :: <span class="label">Int</span>
<span class="title">x</span> = <span class="number">3</span>
<span class="title">y</span> :: <span class="label">Float</span>
<span class="title">y</span> = <span class="number">2.4</span>
<span class="title">main</span> = print (f x y) <span class="comment">-- won't work because type x ≠ type y</span>
</code></pre>


</div>
<p>编译器报错.
两个参数必须类型一致.</p>

<p>如果你坚持这个想法不好, 那么就让编译器帮你从一个类型转到另一个, 你很应该看这个不错(也有趣)的视频:
<a href="https://www.destroyallsoftware.com/talks/wat">WAT</a></p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/24_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>24_very_basic.lhs</strong> </a></p>

<h2 id="essential-haskell">基础的 Haskell</h2>

<p><img alt="Kandinsky Gugg" src="./Learn Haskell Fast and Hard_files/kandinsky_gugg.jpg"></p>

<p>我建议你这部分只是浏览.
当作一份手册.
Haskell 有大量特性.
很多信息这里没有给出.
看起费解的记法了可以回来看.</p>

<p>我用 <code>⇔</code> 符号标示两个表达式等价.
这是个元符号, <code>⇔</code> 不属于 Haskell 语法.
我也会用 <code>⇒</code> 标示 Haskell 表达式的返回值.</p>

<h3 id="notations">记法</h3>

<h5 id="arithmetic">算术</h5>

<pre><code class="markdown">3 + 2 <span class="bullet">* 6 / 3 ⇔ 3 + ((2*</span>6)/3)
</code></pre>

<h5 id="logic">逻辑</h5>

<pre><code class="python"><span class="built_in">True</span> || <span class="built_in">False</span> ⇒ <span class="built_in">True</span>
<span class="built_in">True</span> &amp;&amp; <span class="built_in">False</span> ⇒ <span class="built_in">False</span>
<span class="built_in">True</span> == <span class="built_in">False</span> ⇒ <span class="built_in">False</span>
<span class="built_in">True</span> /= <span class="built_in">False</span> ⇒ <span class="built_in">True</span>  (/=) <span class="keyword">is</span> the operator <span class="keyword">for</span> different
</code></pre>

<h5 id="powers">Powers</h5>

<pre><code class="perl"><span class="keyword">x</span>^n     <span class="keyword">for</span> n an integral (understand Int <span class="keyword">or</span> Integer)
<span class="keyword">x</span><span class="variable">**</span><span class="keyword">y</span>    <span class="keyword">for</span> <span class="keyword">y</span> any kind of number (Float <span class="keyword">for</span> example)
</code></pre>

<p><code>Integer</code> 没有上限, 而你的设备会到极限:</p>

<pre><code class="parser3"><span class="number">4</span><span class="keyword">^103</span>
<span class="number">102844034832575377634685573909834406561420991602098741459288064</span>
</code></pre>

<p>对!
还有分数 FTW!
但你需要 import 一个模块 <code>Data.Ratio</code>:</p>

<pre><code class="avrasm">$ ghci
....
Prelude&gt; :m Data<span class="preprocessor">.Ratio</span>
Data<span class="preprocessor">.Ratio</span>&gt; (<span class="number">11</span> % <span class="number">15</span>) * (<span class="number">5</span> % <span class="number">3</span>)
<span class="number">11</span> % <span class="number">9</span>
</code></pre>

<h5 id="lists">Lists</h5>

<pre><code class="css"><span class="attr_selector">[]</span>                      ⇔ <span class="tag">empty</span> <span class="tag">list</span>
<span class="attr_selector">[1,2,3]</span>                 ⇔ <span class="tag">List</span> <span class="tag">of</span> <span class="tag">integral</span>
<span class="attr_selector">["foo","bar","baz"]</span>     ⇔ <span class="tag">List</span> <span class="tag">of</span> <span class="tag">String</span>
1:<span class="attr_selector">[2,3]</span>                 ⇔ <span class="attr_selector">[1,2,3]</span>, (<span class="pseudo">:)</span> <span class="tag">prepend</span> <span class="tag">one</span> <span class="tag">element</span>
1<span class="pseudo">:2</span>:<span class="attr_selector">[]</span>                  ⇔ <span class="attr_selector">[1,2]</span>
<span class="attr_selector">[1,2]</span> ++ <span class="attr_selector">[3,4]</span>          ⇔ <span class="attr_selector">[1,2,3,4]</span>, (++) <span class="tag">concatenate</span>
<span class="attr_selector">[1,2,3]</span> ++ <span class="attr_selector">["foo"]</span>      ⇔ <span class="tag">ERROR</span> <span class="tag">String</span> ≠ <span class="tag">Integral</span>
<span class="attr_selector">[1..4]</span>                  ⇔ <span class="attr_selector">[1,2,3,4]</span>
<span class="attr_selector">[1,3..10]</span>               ⇔ <span class="attr_selector">[1,3,5,7,9]</span>
<span class="attr_selector">[2,3,5,7,11..100]</span>       ⇔ <span class="tag">ERROR</span>! <span class="tag">I</span> <span class="tag">am</span> <span class="tag">not</span> <span class="tag">so</span> <span class="tag">smart</span>!
<span class="attr_selector">[10,9..1]</span>               ⇔ <span class="attr_selector">[10,9,8,7,6,5,4,3,2,1]</span>
</code></pre>

<h5 id="strings">Strings</h5>

<p>Haskell 里 strings 是 <code>Char</code> 组成的 list.</p>

<pre><code class="objectivec"><span class="string">'a'</span> :: Char
<span class="string">"a"</span> :: [Char]
<span class="string">""</span>  ⇔ []
<span class="string">"ab"</span> ⇔ [<span class="string">'a'</span>,<span class="string">'b'</span>] ⇔  <span class="string">'a'</span>:<span class="string">"b"</span> ⇔ <span class="string">'a'</span>:[<span class="string">'b'</span>] ⇔ <span class="string">'a'</span>:<span class="string">'b'</span>:[]
<span class="string">"abc"</span> ⇔ <span class="string">"ab"</span>++<span class="string">"c"</span>
</code></pre>

<blockquote>
  <p><em>注意</em>:
实际编写代码是你不应该用 char 的 list 来表示文本.
大多数情况你应该用 <code>Data.Text</code>.
如果你想像是 ASCII char 的文本流, 你该用 <code>Data.ByteString</code>.</p>
</blockquote>

<h5 id="tuples">Tuples</h5>

<p>两个元素的 tuple 类型为 <code>(a,b)</code>.
tuple 允许元素属于不同类型.</p>

<pre><code class="avrasm">-- All these tuple are valid
(<span class="number">2</span>,<span class="string">"foo"</span>)
(<span class="number">3</span>,<span class="string">'a'</span>,[<span class="number">2</span>,<span class="number">3</span>])
((<span class="number">2</span>,<span class="string">"a"</span>),<span class="string">"c"</span>,<span class="number">3</span>)

fst (<span class="built_in">x</span>,<span class="built_in">y</span>)       ⇒  <span class="built_in">x</span>
snd (<span class="built_in">x</span>,<span class="built_in">y</span>)       ⇒  <span class="built_in">y</span>

fst (<span class="built_in">x</span>,<span class="built_in">y</span>,<span class="built_in">z</span>)     ⇒  ERROR: fst :: (a,b) -&gt; a
snd (<span class="built_in">x</span>,<span class="built_in">y</span>,<span class="built_in">z</span>)     ⇒  ERROR: snd :: (a,b) -&gt; b
</code></pre>

<h5 id="deal-with-parentheses">处理圆括号</h5>

<p>可以用两个函数还下一部分括号: <code>($)</code> 和 <code>(.)</code>.</p>

<pre><code class="perl">-- By default:
f g h <span class="keyword">x</span>         ⇔  (((f g) h) <span class="keyword">x</span>)

-- the $ replace parenthesis from the $
-- to the end of the expression
f g $ h <span class="keyword">x</span>       ⇔  f g (h <span class="keyword">x</span>) ⇔ (f g) (h <span class="keyword">x</span>)
f $ g h <span class="keyword">x</span>       ⇔  f (g h <span class="keyword">x</span>) ⇔ f ((g h) <span class="keyword">x</span>)
f $ g $ h <span class="keyword">x</span>     ⇔  f (g (h <span class="keyword">x</span>))

-- (.) the composition function
(f . g) <span class="keyword">x</span>       ⇔  f (g <span class="keyword">x</span>)
(f . g . h) <span class="keyword">x</span>   ⇔  f (g (h <span class="keyword">x</span>))
</code></pre>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/20_Essential_Haskell/10a_Functions.lhs" class="cut">01_basic/20_Essential_Haskell/<strong>10a_Functions.lhs</strong></a></p>

<h3 id="useful-notations-for-functions">常用函数记法</h3>

<p>留意下:</p>

<pre><code class="lua">x :: Int            ⇔ x is of <span class="built_in">type</span> Int
x :: a              ⇔ x can be of any <span class="built_in">type</span>
x :: Num a =&gt; a     ⇔ x can be any <span class="built_in">type</span> a
                      such that a belongs to Num <span class="built_in">type</span> class
f :: a -&gt; b         ⇔ f is a <span class="function"><span class="keyword">function</span> <span class="title">from</span> <span class="title">a</span> <span class="title">to</span> <span class="title">b</span>
<span class="title">f</span> :: <span class="title">a</span> -&gt; <span class="title">b</span> -&gt; <span class="title">c</span>    ⇔ <span class="title">f</span> <span class="title">is</span> <span class="title">a</span> <span class="title">function</span> <span class="title">from</span> <span class="title">a</span> <span class="title">to</span> <span class="params">(b→c)</span></span>
f :: (a -&gt; b) -&gt; c  ⇔ f is a <span class="function"><span class="keyword">function</span> <span class="title">from</span> <span class="params">(a→b)</span></span> to c
</code></pre>

<p>在函数定义前声明其类型不是强制性的.
Haskell 会自行推断出最宽泛的类型.
但声明类型是一个好的实践.</p>

<p><em>中缀表示法</em></p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">square</span> :: <span class="label">Num</span> a =&gt; a -&gt; a
<span class="title">square</span> x = x^<span class="number">2</span>
</code></pre>


</div>
<p>注意 <code>^</code> 用了中缀表示法.
每个中缀表示法有对应的前缀表示法.
只要加上括号.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">square'</span> x = (^) x <span class="number">2</span>

<span class="title">square''</span> x = (^<span class="number">2</span>) x
</code></pre>


</div>
<p>两边的 <code>x</code> 可以约掉.
这叫做 η-reduction.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">square'''</span> = (^<span class="number">2</span>)
</code></pre>


</div>
<p>注意我们可以定义含有 <code>'</code> 的函数名.
Here:</p>

<blockquote>
  <p><code>square</code> ⇔  <code>square'</code> ⇔ <code>square''</code> ⇔ <code>square '''</code></p>
</blockquote>

<p><em>判别</em></p>

<p>absolute 函数的一个实现.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">absolute</span> :: (<span class="label">Ord</span> a, <span class="label">Num</span> a) =&gt; a -&gt; a
<span class="title">absolute</span> x = <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">then</span> x <span class="keyword">else</span> -x
</code></pre>


</div>
<p>注意: Haskell 表达式 <code>if .. then .. else</code> 很像
C 语言操作符 <code>¤?¤:¤</code>. 不能遗漏后面的 <code>else</code>.</p>

<p>另一个等价的版本:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">absolute'</span> x
    | x &gt;= <span class="number">0</span> = x
    | otherwise = -x
</code></pre>


</div>
<blockquote>
  <p>关于表示法的警告: Haskell 里缩进<em>很重要</em>.
好比 Python, 出错的缩进会破坏代码.</p>
</blockquote>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = <span class="keyword">do</span>
      print $ square <span class="number">10</span>
      print $ square' <span class="number">10</span>
      print $ square'' <span class="number">10</span>
      print $ square''' <span class="number">10</span>
      print $ absolute <span class="number">10</span>
      print $ absolute (-<span class="number">10</span>)
      print $ absolute' <span class="number">10</span>
      print $ absolute' (-<span class="number">10</span>)
</code></pre>


</div>
</div>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/20_Essential_Haskell/10a_Functions.lhs" class="cut">01_basic/20_Essential_Haskell/<strong>10a_Functions.lhs</strong> </a></p>

<h2 id="hard-part">难点</h2>

<p>现在开始讲难点.</p>

<h3 id="functional-style">函数风格</h3>

<p><img alt="Biomechanical Landscape by H.R. Giger" src="./Learn Haskell Fast and Hard_files/hr_giger_biomechanicallandscape_500.jpg"></p>

<p>这一章, 我会给个关于 Haskell 令人印象深刻的重构能力的小例子.
我们会选个问题然后用标准的命令式办法去解决掉.
然后我会让代码演进.
最终结果会更优雅更容易接受.</p>

<p>来解决以下问题:</p>

<blockquote>
  <p>给定 integer 的 list, 返回 list 中偶数的和.</p>

  <p>例如:
<code>[1,2,3,4,5] ⇒  2 + 4 ⇒  6</code></p>
</blockquote>

<p>为展示函数式和命令式方案的不同,
我开始会提供一个命令式的方案 (JavaScript):</p>

<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">evenSum</span><span class="params">(list)</span> {</span>
    <span class="keyword">var</span> result = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; list.length ; i++) {
        <span class="keyword">if</span> (list[i] % <span class="number">2</span> ==<span class="number">0</span>) {
            result += list[i];
        }
    }
    <span class="keyword">return</span> result;
}
</code></pre>

<p>但 Haskell 里没有变量, 也没循环.
一个不用循环而完成相同结果的解法是用递归.</p>

<blockquote>
  <p><em>注意</em>:<br>
在命令式语言里递归通常被认为缓慢.
但在函数式编程里通常不是那种状况.
大多数情况下 Haskell 会把递归函数处理得很高效</p>
</blockquote>

<p>这是个 <code>C</code> 版本的递归函数.
注意简单起见, 我设定第一个 <code>0</code> 值表示 int list 的结尾.</p>

<pre><code class="c perl"><span class="keyword">int</span> evenSum(<span class="keyword">int</span> <span class="variable">*list</span>) {
    <span class="keyword">return</span> accumSum(<span class="number">0</span>,list);
}

<span class="keyword">int</span> accumSum(<span class="keyword">int</span> n, <span class="keyword">int</span> <span class="variable">*list</span>) {
    <span class="keyword">int</span> <span class="keyword">x</span>;
    <span class="keyword">int</span> <span class="variable">*xs</span>;
    <span class="keyword">if</span> (<span class="variable">*list</span> == <span class="number">0</span>) { <span class="regexp">//</span> <span class="keyword">if</span> the list is empty
        <span class="keyword">return</span> n;
    } <span class="keyword">else</span> {
        <span class="keyword">x</span> = list[<span class="number">0</span>]; <span class="regexp">//</span> let <span class="keyword">x</span> be the first element of the list
        xs = list+<span class="number">1</span>; <span class="regexp">//</span> let xs be the list without <span class="keyword">x</span>
        <span class="keyword">if</span> ( <span class="number">0</span> == (<span class="keyword">x</span><span class="variable">%2</span>) ) { <span class="regexp">//</span> <span class="keyword">if</span> <span class="keyword">x</span> is even
            <span class="keyword">return</span> accumSum(n+<span class="keyword">x</span>, xs);
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> accumSum(n, xs);
        }
    }
}
</code></pre>

<p>
考虑下这段代码. 我们会把它转成 Haskell.
但这之前, 我要介绍下我们会用到的三个简单却使用的函数:</p>

<pre><code class="haskell"><span class="title">even</span> :: <span class="label">Integral</span> a =&gt; a -&gt; <span class="label">Bool</span>
<span class="title">head</span> :: [a] -&gt; a
<span class="title">tail</span> :: [a] -&gt; [a]
</code></pre>

<p><code>even</code> 验证数字是否偶数.</p>

<pre><code class="haskell"><span class="title">even</span> :: <span class="label">Integral</span> a =&gt; a -&gt; <span class="label">Bool</span>
<span class="title">even</span> <span class="number">3</span>  ⇒ <span class="label">False</span>
<span class="title">even</span> <span class="number">2</span>  ⇒ <span class="label">True</span>
</code></pre>

<p><code>head</code> 返回 list 第一个元素:</p>

<pre><code class="haskell"><span class="title">head</span> :: [a] -&gt; a
<span class="title">head</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ⇒ <span class="number">1</span>
<span class="title">head</span> []      ⇒ <span class="label">ERROR</span>
</code></pre>

<p><code>tail</code> 返回第一个元素以外所有元素:</p>

<pre><code class="haskell"><span class="title">tail</span> :: [a] -&gt; [a]
<span class="title">tail</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ⇒ [<span class="number">2</span>,<span class="number">3</span>]
<span class="title">tail</span> [<span class="number">3</span>]     ⇒ []
<span class="title">tail</span> []      ⇒ <span class="label">ERROR</span>
</code></pre>

<p>记下, 对任一非空 list <code>l</code>,
<code>l ⇔ (head l):(tail l)</code></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/11_Functions.lhs" class="cut">02_Hard_Part/<strong>11_Functions.lhs</strong></a></p>

<p>Haskell 第一个解法.
函数 <code>evenSum</code> 返回列表里所有偶数的和:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- Version 1</span>
<span class="title">evenSum</span> :: [<span class="label">Integer</span>] -&gt; <span class="label">Integer</span>

<span class="title">evenSum</span> l = accumSum <span class="number">0</span> l

<span class="title">accumSum</span> n l = <span class="keyword">if</span> l == []
                  <span class="keyword">then</span> n
                  <span class="keyword">else</span> <span class="keyword">let</span> x = head l
                           xs = tail l
                       <span class="keyword">in</span> <span class="keyword">if</span> even x
                              <span class="keyword">then</span> accumSum (n+x) xs
                              <span class="keyword">else</span> accumSum n xs
</code></pre>


</div>
<p>对函数的测试可以用 <code>ghci</code>:</p>

<pre>% ghci
<span class="low">GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude&gt;</span> :load 11_Functions.lhs
<span class="low">[1 of 1] Compiling Main             ( 11_Functions.lhs, interpreted )
Ok, modules loaded: Main.
*Main&gt;</span> evenSum [1..5]
6
</pre>

<p>一个执行的例子<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>: </p>

<pre>*Main&gt; evenSum [1..5]
accumSum 0 [1,2,3,4,5]
<span class="yellow">1 is odd</span>
accumSum 0 [2,3,4,5]
<span class="yellow">2 is even</span>
accumSum (0+2) [3,4,5]
<span class="yellow">3 is odd</span>
accumSum (0+2) [4,5]
<span class="yellow">4 is even</span>
accumSum (0+2+4) [5]
<span class="yellow">5 is odd</span>
accumSum (0+2+4) []
<span class="yellow">l == []</span>
0+2+4
0+6
6
</pre>

<p>从命令式编程译过来看起来应该都没问题.
其实有很多能改进的.
首先, 可以将类型一般化.</p>

<pre><code class="haskell"><span class="title">evenSum</span> :: <span class="label">Integral</span> a =&gt; [a] -&gt; a
</code></pre>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = <span class="keyword">do</span> print $ evenSum [<span class="number">1.</span>.<span class="number">10</span>]
</code></pre>


</div>
</div>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/11_Functions.lhs" class="cut">02_Hard_Part/<strong>11_Functions.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/12_Functions.lhs" class="cut">02_Hard_Part/<strong>12_Functions.lhs</strong></a></p>

<p>接着, 可以用 sub function 用 <code>where</code> 或 <code>let</code>.
借此避免 <code>accumSum</code> 函数污染全局变量.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- Version 2</span>
<span class="title">evenSum</span> :: <span class="label">Integral</span> a =&gt; [a] -&gt; a

<span class="title">evenSum</span> l = accumSum <span class="number">0</span> l
    <span class="keyword">where</span> accumSum n l =
            <span class="keyword">if</span> l == []
                <span class="keyword">then</span> n
                <span class="keyword">else</span> <span class="keyword">let</span> x = head l
                         xs = tail l
                     <span class="keyword">in</span> <span class="keyword">if</span> even x
                            <span class="keyword">then</span> accumSum (n+x) xs
                            <span class="keyword">else</span> accumSum n xs
</code></pre>


</div>
<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = print $ evenSum [<span class="number">1.</span>.<span class="number">10</span>]
</code></pre>


</div>
</div>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/12_Functions.lhs" class="cut">02_Hard_Part/<strong>12_Functions.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/13_Functions.lhs" class="cut">02_Hard_Part/<strong>13_Functions.lhs</strong></a></p>

<p>接下来, 用类型匹配.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- Version 3</span>
<span class="title">evenSum</span> l = accumSum <span class="number">0</span> l
    <span class="keyword">where</span>
        accumSum n [] = n
        accumSum n (x:xs) =
             <span class="keyword">if</span> even x
                <span class="keyword">then</span> accumSum (n+x) xs
                <span class="keyword">else</span> accumSum n xs
</code></pre>


</div>
<p>什么是模式匹配?
用值替代普通函数名<sup id="fnref:021301"><a href="#fn:021301" rel="footnote">3</a></sup>.</p>

<p>除了去说: <code>foo l = if l == [] then &lt;x&gt; else &lt;y&gt;</code>
简单地表示:  </p>

<pre><code class="haskell"><span class="title">foo</span> [] =  &lt;x&gt;
<span class="title">foo</span> l  =  &lt;y&gt;
</code></pre>

<p>不过模式匹配想得更远..
而且可以探测复杂数值内部的数据.
可以替换</p>

<pre><code class="haskell"><span class="title">foo</span> l =  <span class="keyword">let</span> x  = head l
             xs = tail l
         <span class="keyword">in</span> <span class="keyword">if</span> even x
             <span class="keyword">then</span> foo (n+x) xs
             <span class="keyword">else</span> foo n xs
</code></pre>

<p>为</p>

<pre><code class="haskell"><span class="title">foo</span> (x:xs) = <span class="keyword">if</span> even x
                 <span class="keyword">then</span> foo (n+x) xs
                 <span class="keyword">else</span> foo n xs
</code></pre>

<p>这是个很有用的功能.
这让代码读起来更简洁更轻松</p>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = print $ evenSum [<span class="number">1.</span>.<span class="number">10</span>]
</code></pre>


</div>
</div>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/13_Functions.lhs" class="cut">02_Hard_Part/<strong>13_Functions.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/14_Functions.lhs" class="cut">02_Hard_Part/<strong>14_Functions.lhs</strong></a></p>

<p>Haskell 里可以用 η-reducing 简化函数定义.
比如, 不必写:</p>

<pre><code class="haskell"><span class="title">f</span> x = (some expresion) x
</code></pre>

<p>简单地写</p>

<pre><code class="haskell"><span class="title">f</span> = some expression
</code></pre>

<p>用这种办法可以移除 <code>l</code>:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- Version 4</span>
<span class="title">evenSum</span> :: <span class="label">Integral</span> a =&gt; [a] -&gt; a

<span class="title">evenSum</span> = accumSum <span class="number">0</span>
    <span class="keyword">where</span>
        accumSum n [] = n
        accumSum n (x:xs) =
             <span class="keyword">if</span> even x
                <span class="keyword">then</span> accumSum (n+x) xs
                <span class="keyword">else</span> accumSum n xs
</code></pre>


</div>
<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = print $ evenSum [<span class="number">1.</span>.<span class="number">10</span>]
</code></pre>


</div>
</div>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/14_Functions.lhs" class="cut">02_Hard_Part/<strong>14_Functions.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/15_Functions.lhs" class="cut">02_Hard_Part/<strong>15_Functions.lhs</strong></a></p>

<h4 id="higher-order-functions">高阶函数</h4>

<p><img alt="Escher" src="./Learn Haskell Fast and Hard_files/escher_polygon.png"></p>

<p>为这能更好需要用到高阶函数.
那又是什么呢?
高阶函数是以函数作为参数的函数.</p>

<p>看写例子:</p>

<pre><code class="haskell"><span class="title">filter</span> :: (a -&gt; <span class="label">Bool</span>) -&gt; [a] -&gt; [a]
<span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]
<span class="title">foldl</span> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
</code></pre>

<p>用小一点的步子开始执行.</p>

<pre><code class="haskell"><span class="comment">-- Version 5</span>
<span class="title">evenSum</span> l = mysum <span class="number">0</span> (filter even l)
    <span class="keyword">where</span>
      mysum n [] = n
      mysum n (x:xs) = mysum (n+x) xs
</code></pre>

<p>其中</p>

<pre><code class="haskell"><span class="title">filter</span> even [<span class="number">1.</span>.<span class="number">10</span>] ⇔  [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]
</code></pre>

<p>函数 <code>filter</code> 接收一个类型为 (<code>a -&gt; Bool</code>) 的函数和一个类型为 <code>[a]</code> 的 list. 返回一个只含能让函数返回 <code>true</code> 的元素的 list.</p>

<p>下一步是用一别的办法模拟一个 loop.
我发将用 <code>foldl</code> 函数来累积一个值.
函数 <code>foldl</code> 涵盖了一种广泛的编程模式:</p>

<pre>myfunc list = foo <span class="blue">initialValue</span> <span class="green">list</span>
    foo accumulated []     = accumulated
    foo tmpValue    (x:xs) = foo (<span class="yellow">bar</span> tmpValue x) xs
</pre>

<p>可以替换为:</p>

<pre>myfunc list = foldl <span class="yellow">bar</span> <span class="blue">initialValue</span> <span class="green">list</span>
</pre>

<p>如果你很想了解魔术是怎么实现的.
这里有个 <code>foldl</code> 的函数定义.</p>

<pre><code class="haskell"><span class="title">foldl</span> f z [] = z
<span class="title">foldl</span> f z (x:xs) = foldl f (f z x) xs
</code></pre>

<pre><code class="haskell"><span class="title">foldl</span> f z [x1,...xn]
⇔  f (... (f (f z x1) x2) ...) xn
</code></pre>

<p>但由于 Haskell 的惰性, 她不会把代码 <code>(f z x)</code> 执行和推进栈里.
因此会广泛用 <code>foldl'</code> 代替 <code>foldl</code>;
<code>foldl'</code> 是 <code>foldl</code> 的 <em>strict</em> 版本.
如果不懂惰性和strict 的意思,
别担心, 继续看代码就好了就当 <code>foldl</code> 和 <code>foldl'</code> 是一致的.</p>

<p>那么 <code>evenSum</code> 新的版本有了:</p>

<pre><code class="haskell"><span class="comment">-- Version 6</span>
<span class="comment">-- foldl' isn't accessible by default</span>
<span class="comment">-- we need to import it from the module Data.List</span>
<span class="import"><span class="keyword">import</span> Data.List</span>
<span class="title">evenSum</span> l = foldl' mysum <span class="number">0</span> (filter even l)
  <span class="keyword">where</span> mysum acc value = acc + value
</code></pre>

<p>这个版本可以直接用 lambda 表达式来简化.
这样就不用借助临时的 <code>mysum</code> 了.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- Version 7</span>
<span class="comment">-- Generally it is considered a good practice</span>
<span class="comment">-- to import only the necessary function(s)</span>
<span class="import"><span class="keyword">import</span> Data.List <span class="container">(<span class="title">foldl'</span>)</span></span>
<span class="title">evenSum</span> l = foldl' (\x y -&gt; x+y) <span class="number">0</span> (filter even l)
</code></pre>


</div>
<p>而且当然, 注意到</p>

<pre><code class="haskell">(\x y -&gt; x+y) ⇔ (+)
</code></pre>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = print $ evenSum [<span class="number">1.</span>.<span class="number">10</span>]
</code></pre>


</div>
</div>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/15_Functions.lhs" class="cut">02_Hard_Part/<strong>15_Functions.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/16_Functions.lhs" class="cut">02_Hard_Part/<strong>16_Functions.lhs</strong></a></p>

<p>最终</p>

<pre><code class="haskell"><span class="comment">-- Version 8</span>
<span class="import"><span class="keyword">import</span> Data.List <span class="container">(<span class="title">foldl'</span>)</span></span>
<span class="title">evenSum</span> :: <span class="label">Integral</span> a =&gt; [a] -&gt; a
<span class="title">evenSum</span> l = foldl' (+) <span class="number">0</span> (filter even l)
</code></pre>

<p><code>foldl'</code> 直观上并不是最简单的函数.
如果你对它不太习惯, 那该琢磨一下.</p>

<p>为了更容易明白这里发生了什么, 一步一步地求值:</p>

<pre>  <span class="yellow">evenSum [1,2,3,4]</span>
⇒ foldl' (+) 0 (<span class="yellow">filter even [1,2,3,4]</span>)
⇒ <span class="yellow">foldl' (+) 0 <span class="blue">[2,4]</span></span>
⇒ <span class="blue">foldl' (+) (<span class="yellow">0+2</span>) [4]</span>
⇒ <span class="yellow">foldl' (+) <span class="blue">2</span> [4]</span>
⇒ <span class="blue">foldl' (+) (<span class="yellow">2+4</span>) []</span>
⇒ <span class="yellow">foldl' (+) <span class="blue">6</span> []</span>
⇒ <span class="blue">6</span>
</pre>

<p>另一个有用的高阶函数是 <code>(.)</code>.
函数 <code>(.)</code> 相当于数学上的函数复合.</p>

<pre><code class="haskell">(f . g . h) x ⇔  f ( g (h x))
</code></pre>

<p>可以借助这个运算符对函数进行 η-reduce :</p>

<pre><code class="haskell"><span class="comment">-- Version 9</span>
<span class="import"><span class="keyword">import</span> Data.List <span class="container">(<span class="title">foldl'</span>)</span></span>
<span class="title">evenSum</span> :: <span class="label">Integral</span> a =&gt; [a] -&gt; a
<span class="title">evenSum</span> = (foldl' (+) <span class="number">0</span>) . (filter even)
</code></pre>

<p>而且, 一些重命名之后更清爽了:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- Version 10 </span>
<span class="import"><span class="keyword">import</span> Data.List <span class="container">(<span class="title">foldl'</span>)</span></span>
<span class="title">sum'</span> :: (<span class="label">Num</span> a) =&gt; [a] -&gt; a
<span class="title">sum'</span> = foldl' (+) <span class="number">0</span>
<span class="title">evenSum</span> :: <span class="label">Integral</span> a =&gt; [a] -&gt; a
<span class="title">evenSum</span> = sum' . (filter even)

</code></pre>


</div>
<p>现在该讨论下了.
高阶函数能给我们带来什么?</p>

<p>首先, 可以说它简练.
但其实, 好好想想还有很多.
假设要对我们的函数做轻微的修改,
想获取 list 中所有奇数的平方和.</p>

<pre><code class="css"><span class="attr_selector">[1,2,3,4]</span> ▷ <span class="attr_selector">[1,4,9,16]</span> ▷ <span class="attr_selector">[4,16]</span> ▷ 20
</code></pre>

<p>修改版本 10 超简单:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">squareEvenSum</span> = sum' . (filter even) . (map (^<span class="number">2</span>))
<span class="title">squareEvenSum'</span> = evenSum . (map (^<span class="number">2</span>))
<span class="title">squareEvenSum''</span> = sum' . (map (^<span class="number">2</span>)) . (filter even)
</code></pre>


</div>
<p>只需要添加另一个“变换函数”<sup id="fnref:0216"><a href="#fn:0216" rel="footnote">4</a></sup>.</p>

<pre><code class="css"><span class="tag">map</span> (^2) <span class="attr_selector">[1,2,3,4]</span> ⇔ <span class="attr_selector">[1,4,9,16]</span>
</code></pre>

<p>函数 <code>map</code> 直白地把函数施加到 list 里每个元素.</p>

<p>不需要修改函数定义 <em>内部</em> 任何代码.
看起来更模块化.
不过同时你对于函数的认识会更数学化.
你能像用别的函数一样使用这个函数. 可以符合, map, fold, filter 这个函数.</p>

<p>留给读者一个习题, 去修改版本 1. ☺.</p>

<p>如果你认为已经一般化到了几点, 那实际上你非常得错误.
比如有一条是把函数作用于任何递归类型, 而不只用在 list 里.
如果你想了解更多, 建议看下这篇有趣的文章:
<a href="http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire by Meijer, Fokkinga and Paterson</a>.</p>

<p>例子应该已经想你展示纯函数式编程能有多棒了.
不幸的是, 纯函数编程并不能很好地适用于所有情形.
或者至少还没有那样一门语言.</p>

<p>Haskell 一项强大之处是用于创建 DSL
(Domain Specific Language)
使之更易于改变编程范式.</p>

<p>实际上, Haskell 在命令式编程时也很棒.
我当初学 Haskell 很男想明白这一点.
做了大量的努力解释了函数式的解法佛么优越,
然后去用 Haskell 写命令式, 这真很令人费解.</p>

<p>不过讲 Haskell 的能力前要讲下另一个基本的部分: <em>类型</em>.</p>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = print $ evenSum [<span class="number">1.</span>.<span class="number">10</span>]
</code></pre>


</div>
</div>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/16_Functions.lhs" class="cut">02_Hard_Part/<strong>16_Functions.lhs</strong> </a></p>

<h3 id="types">类型</h3>

<p><img alt="Dali, the madonna of port Lligat" src="./Learn Haskell Fast and Hard_files/salvador-dali-the-madonna-of-port-lligat.jpg"></p>

<blockquote>
  <p><span class="sc"><abbr title="Too long; didn&#39;t read">tl;dr</abbr>: </span></p>

  <ul>
    <li><code>type Name = AnotherType</code> 这只是个名称,对编译器来说 <code>Name</code> 和 <code>AnotherType</code> 没啥不同.</li>
    <li><code>data Name = NameConstructor AnotherType</code> 不大一样.</li>
    <li><code>data</code> 可以构建可递归的类型.</li>
    <li><code>deriving</code> 的魔法用来为你创建函数.</li>
  </ul>
</blockquote>

<p>Haskell 里, 是强类型, 是静态类型.</p>

<p>为什么这很重要? 因为这可以 <em>很大程度上</em> 帮你规避错误.
Haskell 大多 bug 可以在崇虚编译阶段捕获到.
其主要原因就是编译期间的类型推断.
比方你用了错误的参数在错误的位置就很容易检测了.</p>

<h4 id="type-inference">类型推断</h4>

<p>要实现快速执行, 静态类型普遍很重要.
但大多静态语言不善于推广概念.
Haskell 完美解决了通过<em>类型推断</em>.</p>

<p>下面是例子.
Haskell 里的 <code>square</code> 函数:</p>

<pre><code class="haskell"><span class="title">square</span> x = x * x
</code></pre>

<p>函数能 <code>square</code> 所有类型的数值.
用 <code>square</code> 能算 <code>Int</code>, 算 <code>Integer</code>, 算 <code>Float</code> 算 <code>Fractional</code> 甚至 <code>Complex</code>. 例子证明下:</p>

<pre><code class="avrasm">% ghci
GHCi, version <span class="number">7.0</span><span class="number">.4</span>:
...
Prelude&gt; let square <span class="built_in">x</span> = <span class="built_in">x</span>*<span class="built_in">x</span>
Prelude&gt; square <span class="number">2</span>
<span class="number">4</span>
Prelude&gt; square <span class="number">2.1</span>
<span class="number">4.41</span>
Prelude&gt; -- load the Data<span class="preprocessor">.Complex</span> module
Prelude&gt; :m Data<span class="preprocessor">.Complex</span>
Prelude Data<span class="preprocessor">.Complex</span>&gt; square (<span class="number">2</span> :+ <span class="number">1</span>)
<span class="number">3.0</span> :+ <span class="number">4.0</span>
</code></pre>

<p><code>x :+ y</code> 是复数 (<i>x + ib</i>) 的表示法.</p>

<p>再和 C 所需的代码量对比下:</p>

<pre><code class="c avrasm">int     int_square(int <span class="built_in">x</span>) { return <span class="built_in">x</span>*<span class="built_in">x</span><span class="comment">; }</span>

float   float_square(float <span class="built_in">x</span>) {return <span class="built_in">x</span>*<span class="built_in">x</span><span class="comment">; }</span>

complex complex_square (complex <span class="built_in">z</span>) {
    complex tmp<span class="comment">; </span>
    tmp<span class="preprocessor">.real</span> = <span class="built_in">z</span><span class="preprocessor">.real</span> * <span class="built_in">z</span><span class="preprocessor">.real</span> - <span class="built_in">z</span><span class="preprocessor">.img</span> * <span class="built_in">z</span><span class="preprocessor">.img</span><span class="comment">;</span>
    tmp<span class="preprocessor">.img</span> = <span class="number">2</span> * <span class="built_in">z</span><span class="preprocessor">.img</span> * <span class="built_in">z</span><span class="preprocessor">.real</span><span class="comment">;</span>
}

complex <span class="built_in">x</span>,<span class="built_in">y</span><span class="comment">;</span>
<span class="built_in">y</span> = complex_square(<span class="built_in">x</span>)<span class="comment">;</span>
</code></pre>

<p>每个类型你都要重新写函数.
剩下的解法只有去用一些元编程技巧.
比如用 pre-processor. C++ 里办法好点, C++ templates:</p>

<pre><code class="c++ vala"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;complex&gt;</span>
<span class="keyword">using</span> <span class="class">namespace <span class="title">std</span>;

<span class="title">template</span>&lt;<span class="title">typename</span> <span class="title">T</span>&gt;
<span class="title">T</span> <span class="title">square</span>(<span class="title">T</span> <span class="title">x</span>)
{</span>
    <span class="keyword">return</span> x*x;
}

<span class="keyword">int</span> main() {
    <span class="comment">// int</span>
    <span class="keyword">int</span> sqr_of_five = square(<span class="number">5</span>);
    cout &lt;&lt; sqr_of_five &lt;&lt; endl;
    <span class="comment">// double</span>
    cout &lt;&lt; (<span class="keyword">double</span>)square(<span class="number">5.3</span>) &lt;&lt; endl;
    <span class="comment">// complex</span>
    cout &lt;&lt; square( complex&lt;<span class="keyword">double</span>&gt;(<span class="number">5</span>,<span class="number">3</span>) )
         &lt;&lt; endl;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

<p>C++ 比 C 干得要好很多.
更复杂的函数里语法可以很难习惯:
看
<a href="http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/">这篇文章</a>
的例子.</p>

<p>C++ 里必须声明函数可以运行不同的类型.
Haskell 里相反.
函数默认会尽可能一般化.</p>

<p>类型推断让 Haskell 有那种动态语言才有的自由感.
只是跟动态语言不同的是, 大多错误在代码执行钱就能捕获.
通常对于 Haskell:</p>

<blockquote>
  <p>“只要编译成功了, 她就该是你想的那样运行.” </p>
</blockquote>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/21_Types.lhs" class="cut">02_Hard_Part/<strong>21_Types.lhs</strong></a></p>

<h4 id="type-construction">类型构造</h4>

<p>你可以自己构建类型.
首先你可以创建别名或同义词类型.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="class"><span class="keyword">type</span> <span class="label">Name</span>   = <span class="label">String</span></span>
<span class="class"><span class="keyword">type</span> <span class="label">Color</span>  = <span class="label">String</span></span>

<span class="title">showInfos</span> :: <span class="label">Name</span> -&gt;  <span class="label">Color</span> -&gt; <span class="label">String</span>
<span class="title">showInfos</span> name color =  <span class="string">"Name: "</span> ++ name
                        ++ <span class="string">", Color: "</span> ++ color
<span class="title">name</span> :: <span class="label">Name</span>
<span class="title">name</span> = <span class="string">"Robin"</span>
<span class="title">color</span> :: <span class="label">Color</span>
<span class="title">color</span> = <span class="string">"Blue"</span>
<span class="title">main</span> = putStrLn $ showInfos name color
</code></pre>


</div>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/21_Types.lhs" class="cut">02_Hard_Part/<strong>21_Types.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/22_Types.lhs" class="cut">02_Hard_Part/<strong>22_Types.lhs</strong></a></p>

<p>但这并不把你维护得多好.
尝试下调换 <code>showInfos</code> 两个参数的顺序再运行程序:</p>

<pre><code class="haskell">    putStrLn $ showInfos color name
</code></pre>

<p>编译和运行照常.
实际上你可以替换掉任何地方的 Name, Color 以及 String.
编译器看待她们完全相同.
</p>

<p>另一个创建类型的方法是用 <code>data</code> 关键字.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="class"><span class="keyword">data</span> <span class="label">Name</span>   = <span class="label">NameConstr</span> <span class="label">String</span></span>
<span class="class"><span class="keyword">data</span> <span class="label">Color</span>  = <span class="label">ColorConstr</span> <span class="label">String</span></span>

<span class="title">showInfos</span> :: <span class="label">Name</span> -&gt;  <span class="label">Color</span> -&gt; <span class="label">String</span>
<span class="title">showInfos</span> (<span class="label">NameConstr</span> name) (<span class="label">ColorConstr</span> color) =
      <span class="string">"Name: "</span> ++ name ++ <span class="string">", Color: "</span> ++ color

<span class="title">name</span>  = <span class="label">NameConstr</span> <span class="string">"Robin"</span>
<span class="title">color</span> = <span class="label">ColorConstr</span> <span class="string">"Blue"</span>
<span class="title">main</span> = putStrLn $ showInfos name color
</code></pre>


</div>
<p>现在如果调换 <code>showInfos</code> 两个参数的顺序, 编译器会报错!
那个可能出现的错误你也不会再犯.
代价是代码因此冗长. </p>

<p>同时要注意 contructor 是函数:</p>

<pre><code class="haskell"><span class="label">NameConstr</span>  :: <span class="label">String</span> -&gt; <span class="label">Name</span>
<span class="label">ColorConstr</span> :: <span class="label">String</span> -&gt; <span class="label">Color</span>
</code></pre>

<p> <code>data</code> 语法的主体是:</p>

<pre><code class="haskell"><span class="class"><span class="keyword">data</span> <span class="label">TypeName</span> =   <span class="label">ConstructorName</span>  [types]</span>
                | <span class="label">ConstructorName2</span> [<span class="class">types]</span>
                | ...
</code></pre>

<p>一般的用法是在
DataTypeName 和 DataTypeConstructor 使用一致的名称.</p>

<p>例如:</p>

<pre><code class="haskell"><span class="class"><span class="keyword">data</span> <span class="label">Complex</span> = <span class="label">Num</span> a =&gt; <span class="label">Complex</span> a a</span>
</code></pre>

<p>可以使用记录的(record?)语法:</p>

<pre><code class="haskell"><span class="class"><span class="keyword">data</span> <span class="label">DataTypeName</span> = <span class="label">DataConstructor</span> {</span>
                      field1 :: [<span class="class"><span class="keyword">type</span> of field1]</span>
                    , field2 :: [<span class="class"><span class="keyword">type</span> of field2]</span>
                    ...
                    , fieldn :: [<span class="class"><span class="keyword">type</span> of fieldn] }</span>
</code></pre>

<p>并且有多种存取的方式.
而且赋值时可以使用其他的顺序.</p>

<p>例如:</p>

<pre><code class="haskell"><span class="class"><span class="keyword">data</span> <span class="label">Complex</span> = <span class="label">Num</span> a =&gt; <span class="label">Complex</span> { real :: a, img :: a}</span>
<span class="title">c</span> = <span class="label">Complex</span> <span class="number">1.0</span> <span class="number">2.0</span>
<span class="title">z</span> = <span class="label">Complex</span> { real = <span class="number">3</span>, img = <span class="number">4</span> }
<span class="title">real</span> c ⇒ <span class="number">1.0</span>
<span class="title">img</span> z ⇒ <span class="number">4</span>
</code></pre>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/22_Types.lhs" class="cut">02_Hard_Part/<strong>22_Types.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/23_Types.lhs" class="cut">02_Hard_Part/<strong>23_Types.lhs</strong></a></p>

<h4 id="recursive-type">递归类型</h4>

<p>你已经见过一种递归类型: list.
list 类型可以重新创建, 需要用到冗长的语法:</p>

<pre><code class="haskell"><span class="class"><span class="keyword">data</span> <span class="label">List</span> a = <span class="label">Empty</span> | <span class="label">Cons</span> a (<span class="label">List</span> a)</span>
</code></pre>

<p>要想用更简单的语法你需要对 constructor 使用中缀的名称.</p>

<pre><code class="haskell"><span class="title">infixr</span> <span class="number">5</span> :::
<span class="class"><span class="keyword">data</span> <span class="label">List</span> a = <span class="label">Nil</span> | a ::: (<span class="label">List</span> a)</span>
</code></pre>

<p> <code>infixr</code> 后的数字表示优先级.</p>

<p>为了让定义的数据结构能进行 print (<code>Show</code>), read (<code>Read</code>), 检测 equality (<code>Eq</code>) and compare (<code>Ord</code>) 可以告诉 Haskell 替你派生出适当的函数.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">infixr</span> <span class="number">5</span> :::
<span class="class"><span class="keyword">data</span> <span class="label">List</span> a = <span class="label">Nil</span> | a ::: (<span class="label">List</span> a) </span>
              <span class="keyword">deriving</span> (<span class="label">Show</span>,<span class="label">Read</span>,<span class="label">Eq</span>,<span class="label">Ord</span>)
</code></pre>


</div>
<p>在类型声明加上 <code>deriving (Show)</code> 之后, Haskell 会为你创建一个 <code>show</code> 函数.
接下来很快可以看到怎么去用你的 <code>show</code> 函数.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">convertList</span> [] = <span class="label">Nil</span>
<span class="title">convertList</span> (x:xs) = x ::: convertList xs
</code></pre>


</div>
<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = <span class="keyword">do</span>
      print (<span class="number">0</span> ::: <span class="number">1</span> ::: <span class="label">Nil</span>)
      print (convertList [<span class="number">0</span>,<span class="number">1</span>])
</code></pre>


</div>
<p>这会输出:</p>

<pre><code class="delphi"><span class="number">0</span> ::: (<span class="number">1</span> ::: <span class="keyword">Nil</span>)
<span class="number">0</span> ::: (<span class="number">1</span> ::: <span class="keyword">Nil</span>)
</code></pre>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/23_Types.lhs" class="cut">02_Hard_Part/<strong>23_Types.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/30_Trees.lhs" class="cut">02_Hard_Part/<strong>30_Trees.lhs</strong></a></p>

<h4 id="trees">Trees</h4>

<p><img alt="Magritte, l&#39;Arbre" src="./Learn Haskell Fast and Hard_files/magritte-l-arbre.jpg"></p>

<p>下面会直接给出标准案例: binary trees.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="import"><span class="keyword">import</span> Data.List</span>

<span class="class"><span class="keyword">data</span> <span class="label">BinTree</span> a = <span class="label">Empty</span> </span>
                 | <span class="label">Node</span> a (<span class="label">BinTree</span> a) (<span class="label">BinTree</span> a)
                              <span class="keyword">deriving</span> (<span class="label">Show</span>)
</code></pre>


</div>
<p>下面创建一个函数用来把一个 list 转化为一个有序的 binary tree.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">treeFromList</span> :: (<span class="label">Ord</span> a) =&gt; [a] -&gt; <span class="label">BinTree</span> a
<span class="title">treeFromList</span> [] = <span class="label">Empty</span>
<span class="title">treeFromList</span> (x:xs) = <span class="label">Node</span> x (treeFromList (filter (&lt;x) xs))
                             (treeFromList (filter (&gt;x) xs))
</code></pre>


</div>
<p>看看这个函数多优雅.
用白话说: </p>

<ul>
  <li>空的 list 会被转化成空的 tree.</li>
  <li> list <code>(x:xs)</code> 会被转化为 tree , 满足:
    <ul>
      <li>root 是 <code>x</code></li>
      <li>左子树是 list <code>xs</code> 中严格小于 <code>x</code> 的成员生成的 tree</li>
      <li>右子树是 list <code>xs</code> 中严格大于 <code>x</code> 的成员生成的 tree.</li>
    </ul>
  </li>
</ul>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = print $ treeFromList [<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]
</code></pre>


</div>
<p>得到结果如下:</p>

<pre><code class="php">Node <span class="number">7</span> (Node <span class="number">2</span> <span class="keyword">Empty</span> (Node <span class="number">4</span> <span class="keyword">Empty</span> <span class="keyword">Empty</span>)) (Node <span class="number">8</span> <span class="keyword">Empty</span> <span class="keyword">Empty</span>)
</code></pre>

<p>这是 tree 一种可读的但不漂亮的一种表示.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/30_Trees.lhs" class="cut">02_Hard_Part/<strong>30_Trees.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/31_Trees.lhs" class="cut">02_Hard_Part/<strong>31_Trees.lhs</strong></a></p>

<p>为了更有趣, 给 tree 编写一个更漂亮的表示形式.
我简单地就是很喜欢给 tree 做通用而且漂亮的函数来显示.
如果这部分对你来说太难, 跳过这部分没有问题.</p>

<p>我们要做一些改变.
从 <code>BinTree</code> 类型的声明中移除 <code>deriving (Show)</code>.
让 BinTree 类型成为 (<code>Eq</code> 和 <code>Ord</code>) 的实例也会比较有用.
我们将可以比较和测试两棵树.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="class"><span class="keyword">data</span> <span class="label">BinTree</span> a = <span class="label">Empty</span> </span>
                 | <span class="label">Node</span> a (<span class="label">BinTree</span> a) (<span class="label">BinTree</span> a)
                  <span class="keyword">deriving</span> (<span class="label">Eq</span>,<span class="label">Ord</span>)
</code></pre>


</div>
<p>没有了 <code>deriving (Show)</code>, Haskell 不会为我们创建 <code>show</code> 方法.
我们将自己创建一个 <code>show</code>.
为了将它实现, 必须么声明我们新创建的类型 <code>BinTree a</code>
是类型类 <code>Show</code> 的一个实例.
一般的语法是:</p>

<pre><code class="haskell"><span class="class"><span class="keyword">instance</span> <span class="label">Show</span> (<span class="label">BinTree</span> a) <span class="keyword">where</span></span>
   show t = ... <span class="comment">-- You declare your function here</span>
</code></pre>

<p>下面是我写的展示二叉树的代码.
别担心表面看去的复杂性.
为显示甚至古怪些的对象, 我做了不少的优化.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- declare BinTree a to be an instance of Show</span>
<span class="class"><span class="keyword">instance</span> (<span class="label">Show</span> a) =&gt; <span class="label">Show</span> (<span class="label">BinTree</span> a) <span class="keyword">where</span></span>
  <span class="comment">-- will start by a '&lt;' before the root</span>
  <span class="comment">-- and put a : a begining of line</span>
  show t = <span class="string">"&lt; "</span> ++ replace<span class="string"> '\n'</span> <span class="string">"\n: "</span> (treeshow <span class="string">""</span> t)
    <span class="keyword">where</span>
    <span class="comment">-- treeshow pref Tree </span>
    <span class="comment">--   shows a tree and starts each line with pref</span>
    <span class="comment">-- We don't display the Empty tree</span>
    treeshow pref <span class="label">Empty</span> = <span class="string">""</span>
    <span class="comment">-- Leaf</span>
    treeshow pref (<span class="label">Node</span> x <span class="label">Empty</span> <span class="label">Empty</span>) =
                  (pshow pref x)

    <span class="comment">-- Right branch is empty</span>
    treeshow pref (<span class="label">Node</span> x left <span class="label">Empty</span>) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> left)

    <span class="comment">-- Left branch is empty</span>
    treeshow pref (<span class="label">Node</span> x <span class="label">Empty</span> right) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> right)

    <span class="comment">-- Tree with left and right children non empty</span>
    treeshow pref (<span class="label">Node</span> x left right) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"|--"</span> <span class="string">"|  "</span> left) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> right)

    <span class="comment">-- shows a tree using some prefixes to make it nice</span>
    showSon pref before next t =
                  pref ++ before ++ treeshow (pref ++ next) t

    <span class="comment">-- pshow replaces "\n" by "\n"++pref</span>
    pshow pref x = replace<span class="string"> '\n'</span> (<span class="string">"\n"</span>++pref) (show x)

    <span class="comment">-- replaces one char by another string</span>
    replace c new string =
      concatMap (change c new) string
      <span class="keyword">where</span>
          change c new x
              | x == c = new
              | otherwise = x:[] <span class="comment">-- "x"</span>
</code></pre>


</div>
<p>其中 <code>treeFromList</code> 方法仍然一致.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">treeFromList</span> :: (<span class="label">Ord</span> a) =&gt; [a] -&gt; <span class="label">BinTree</span> a
<span class="title">treeFromList</span> [] = <span class="label">Empty</span>
<span class="title">treeFromList</span> (x:xs) = <span class="label">Node</span> x (treeFromList (filter (&lt;x) xs))
                             (treeFromList (filter (&gt;x) xs))
</code></pre>


</div>
<p>现在我们来演示:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = <span class="keyword">do</span>
  putStrLn <span class="string">"Int binary tree:"</span>
  print $ treeFromList [<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">21</span>,<span class="number">12</span>,<span class="number">23</span>]
</code></pre>


</div>
<pre><code class="lua">Int binary tree:
&lt; <span class="number">7</span>
: |<span class="comment">--2</span>
: |  |<span class="comment">--1</span>
: |  `<span class="comment">--4</span>
: |     |<span class="comment">--3</span>
: |     `<span class="comment">--6</span>
: `<span class="comment">--8</span>
:    `<span class="comment">--21</span>
:       |<span class="comment">--12</span>
:       `<span class="comment">--23</span>
</code></pre>

<p>现在好多了.
根部一行用 <code>&lt;</code> 符号开头.
接下来的没一行以 <code>:</code> 开头.
另外也可以用在另一种类型.</p>

<div class="codehighlight">


<pre><code class="haskell">  putStrLn <span class="string">"\nString binary tree:"</span>
  print $ treeFromList [<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"baz"</span>,<span class="string">"gor"</span>,<span class="string">"yog"</span>]
</code></pre>


</div>
<pre><code class="lua">String binary tree:
&lt; <span class="string">"foo"</span>
: |<span class="comment">--"bar"</span>
: |  `<span class="comment">--"baz"</span>
: `<span class="comment">--"gor"</span>
:    `<span class="comment">--"yog"</span>
</code></pre>

<p>因为能检测 tree 是否相等和顺序,
我们还可以从树创建树!</p>

<div class="codehighlight">


<pre><code class="haskell">  putStrLn <span class="string">"\nBinary tree of Char binary trees:"</span>
  print ( treeFromList
           (map treeFromList [<span class="string">"baz"</span>,<span class="string">"zara"</span>,<span class="string">"bar"</span>]))
</code></pre>


</div>
<pre><code class="haskell"><span class="label">Binary</span> tree <span class="keyword">of</span> <span class="label">Char</span> binary trees:
&lt; &lt;<span class="string"> 'b'</span>
: : |<span class="comment">--'a'</span>
: : `<span class="comment">--'z'</span>
: |<span class="comment">--&lt; 'b'</span>
: |  : |<span class="comment">--'a'</span>
: |  : `<span class="comment">--'r'</span>
: `<span class="comment">--&lt; 'z'</span>
:    : `<span class="comment">--'a'</span>
:    :    `<span class="comment">--'r'</span>
</code></pre>

<p>这就是我让没每一行以 <code>:</code> 开头的原因(根部以外).</p>

<p><img alt="Yo Dawg Tree" src="./Learn Haskell Fast and Hard_files/yo_dawg_tree.jpg"></p>

<div class="codehighlight">


<pre><code class="haskell">  putStrLn <span class="string">"\nTree of Binary trees of Char binary trees:"</span>
  print $ (treeFromList . map (treeFromList . map treeFromList))
             [ [<span class="string">"YO"</span>,<span class="string">"DAWG"</span>]
             , [<span class="string">"I"</span>,<span class="string">"HEARD"</span>]
             , [<span class="string">"I"</span>,<span class="string">"HEARD"</span>]
             , [<span class="string">"YOU"</span>,<span class="string">"LIKE"</span>,<span class="string">"TREES"</span>] ]
</code></pre>


</div>
<p>上面的等价于</p>

<pre><code class="haskell"><span class="title">print</span> ( treeFromList (
          map treeFromList
             [ map treeFromList [<span class="string">"YO"</span>,<span class="string">"DAWG"</span>]
             , map treeFromList [<span class="string">"I"</span>,<span class="string">"HEARD"</span>]
             , map treeFromList [<span class="string">"I"</span>,<span class="string">"HEARD"</span>]
             , map treeFromList [<span class="string">"YOU"</span>,<span class="string">"LIKE"</span>,<span class="string">"TREES"</span>] ]))
</code></pre>

<p>输出:</p>

<pre><code class="haskell"><span class="label">Binary</span> tree <span class="keyword">of</span> <span class="label">Binary</span> trees <span class="keyword">of</span> <span class="label">Char</span> binary trees:
&lt; &lt; &lt;<span class="string"> 'Y'</span>
: : : `<span class="comment">--'O'</span>
: : `<span class="comment">--&lt; 'D'</span>
: :    : |<span class="comment">--'A'</span>
: :    : `<span class="comment">--'W'</span>
: :    :    `<span class="comment">--'G'</span>
: |<span class="comment">--&lt; &lt; 'I'</span>
: |  : `<span class="comment">--&lt; 'H'</span>
: |  :    : |<span class="comment">--'E'</span>
: |  :    : |  `<span class="comment">--'A'</span>
: |  :    : |     `<span class="comment">--'D'</span>
: |  :    : `<span class="comment">--'R'</span>
: `<span class="comment">--&lt; &lt; 'Y'</span>
:    : : `<span class="comment">--'O'</span>
:    : :    `<span class="comment">--'U'</span>
:    : `<span class="comment">--&lt; 'L'</span>
:    :    : `<span class="comment">--'I'</span>
:    :    :    |<span class="comment">--'E'</span>
:    :    :    `<span class="comment">--'K'</span>
:    :    `<span class="comment">--&lt; 'T'</span>
:    :       : `<span class="comment">--'R'</span>
:    :       :    |<span class="comment">--'E'</span>
:    :       :    `<span class="comment">--'S'</span>
</code></pre>

<p>注意重复的 tree 为什么没有被插入;
上面只有一棵树对应 <code>"I","HEARD"</code>.
我们很轻松地将其实现了, 因为我们已经声明了 Tree 是 <code>Eq</code> 类型的实例.</p>

<p>看看这个结构多漂亮.
我们可以创建的 tree 不仅包含整数, 字符串和字符, 还有其他的 tree.
而且我们海南生成包含含有其他 tree 的 tree 的 tree.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/31_Trees.lhs" class="cut">02_Hard_Part/<strong>31_Trees.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/40_Infinites_Structures.lhs" class="cut">02_Hard_Part/<strong>40_Infinites_Structures.lhs</strong></a></p>

<h3 id="infinite-structures">无限结构</h3>

<p><img alt="Escher" src="./Learn Haskell Fast and Hard_files/escher_infinite_lizards.jpg"></p>

<p>Haskell 经常被说是 <em>惰性</em>.</p>

<p>事实上, 如果你迂腐点, 你会说 <a href="http://www.haskell.org/haskellwiki/Lazy_vs._non-strict">Haskell 是 <em>non-strict</em></a>.
惰性是 non-strict 语言一种通常的实现方式.</p>

<p>那么 not-strict 什么意思? 根据 Haskell wiki:</p>

<blockquote>
  <p>递归 (求值的数学术语) 从外部开始执行.</p>

  <p>因此给定 <code>(a+(b*c))</code> 那么 <code>+</code> 会首先约简, 然后内部的 <code>(b*c)</code> 再被约简</p>
</blockquote>

<p>比如 Haskell 里你可以这么做:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- numbers = [1,2,..]</span>
<span class="title">numbers</span> :: [<span class="label">Integer</span>]
<span class="title">numbers</span> = <span class="number">0</span>:map (<span class="number">1</span>+) numbers

<span class="title">take'</span> n [] = []
<span class="title">take'</span> <span class="number">0</span> l = []
<span class="title">take'</span> n (x:xs) = x:take' (n-<span class="number">1</span>) xs

<span class="title">main</span> = print $ take' <span class="number">10</span> numbers
</code></pre>


</div>
<p>而且它可以停下来.</p>

<p>怎么做到?</p>

<p>不是去尝试对 <code>numbers</code> 整个地求值,
只有被需要的元素才会被求值.</p>

<p>而且, 注意 Haskell 里有无限列表的表示法</p>

<pre><code class="css"><span class="attr_selector">[1..]</span>   ⇔ <span class="attr_selector">[1,2,3,4...]</span>
<span class="attr_selector">[1,3..]</span> ⇔ <span class="attr_selector">[1,3,5,7,9,11...]</span>
</code></pre>

<p>绝大多数函数都可以正常处理无限列表.
然后, 有个内置函数 <code>take</code> 和我们的 <code>take'</code> 是等价的.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/40_Infinites_Structures.lhs" class="cut">02_Hard_Part/<strong>40_Infinites_Structures.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/41_Infinites_Structures.lhs" class="cut">02_Hard_Part/<strong>41_Infinites_Structures.lhs</strong></a></p>

<div style="display:none">

This code is mostly the same as the previous one.

<div class="codehighlight">


<pre><code class="haskell"><span class="import"><span class="keyword">import</span> Debug.Trace <span class="container">(<span class="title">trace</span>)</span></span>
<span class="import"><span class="keyword">import</span> Data.List</span>
<span class="class"><span class="keyword">data</span> <span class="label">BinTree</span> a = <span class="label">Empty</span> </span>
                 | <span class="label">Node</span> a (<span class="label">BinTree</span> a) (<span class="label">BinTree</span> a)
                  <span class="keyword">deriving</span> (<span class="label">Eq</span>,<span class="label">Ord</span>)
</code></pre>


</div>
<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- declare BinTree a to be an instance of Show</span>
<span class="class"><span class="keyword">instance</span> (<span class="label">Show</span> a) =&gt; <span class="label">Show</span> (<span class="label">BinTree</span> a) <span class="keyword">where</span></span>
  <span class="comment">-- will start by a '&lt;' before the root</span>
  <span class="comment">-- and put a : a begining of line</span>
  show t = <span class="string">"&lt; "</span> ++ replace<span class="string"> '\n'</span> <span class="string">"\n: "</span> (treeshow <span class="string">""</span> t)
    <span class="keyword">where</span>
    treeshow pref <span class="label">Empty</span> = <span class="string">""</span>
    treeshow pref (<span class="label">Node</span> x <span class="label">Empty</span> <span class="label">Empty</span>) =
                  (pshow pref x)

    treeshow pref (<span class="label">Node</span> x left <span class="label">Empty</span>) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> left)

    treeshow pref (<span class="label">Node</span> x <span class="label">Empty</span> right) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> right)

    treeshow pref (<span class="label">Node</span> x left right) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"|--"</span> <span class="string">"|  "</span> left) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> right)

    <span class="comment">-- show a tree using some prefixes to make it nice</span>
    showSon pref before next t =
                  pref ++ before ++ treeshow (pref ++ next) t

    <span class="comment">-- pshow replace "\n" by "\n"++pref</span>
    pshow pref x = replace<span class="string"> '\n'</span> (<span class="string">"\n"</span>++pref) (<span class="string">" "</span> ++ show x)

    <span class="comment">-- replace on char by another string</span>
    replace c new string =
      concatMap (change c new) string
      <span class="keyword">where</span>
          change c new x
              | x == c = new
              | otherwise = x:[] <span class="comment">-- "x"</span>

</code></pre>


</div>
</div>

<p>假设我们不介意用到有序的二叉树.
这里有棵无限的二叉树:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">nullTree</span> = <span class="label">Node</span> <span class="number">0</span> nullTree nullTree
</code></pre>


</div>
<p>一棵完整的二叉树, 其中每个节点均为 0.
现在我将证明你能用下面的函数操作这个对象:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- take all element of a BinTree </span>
<span class="comment">-- up to some depth</span>
<span class="title">treeTakeDepth</span> _ <span class="label">Empty</span> = <span class="label">Empty</span>
<span class="title">treeTakeDepth</span> <span class="number">0</span> _     = <span class="label">Empty</span>
<span class="title">treeTakeDepth</span> n (<span class="label">Node</span> x left right) = <span class="keyword">let</span>
          nl = treeTakeDepth (n-<span class="number">1</span>) left
          nr = treeTakeDepth (n-<span class="number">1</span>) right
          <span class="keyword">in</span>
              <span class="label">Node</span> x nl nr
</code></pre>


</div>
<p>看看这段程序得到了什么:</p>

<pre><code class="haskell"><span class="title">main</span> = print $ treeTakeDepth <span class="number">4</span> nullTree
</code></pre>

<p>这段代码编译, 执行, 停止, 给出了下面的结果:</p>

<pre><code class="lua">&lt;  <span class="number">0</span>
: |<span class="comment">-- 0</span>
: |  |<span class="comment">-- 0</span>
: |  |  |<span class="comment">-- 0</span>
: |  |  `<span class="comment">-- 0</span>
: |  `<span class="comment">-- 0</span>
: |     |<span class="comment">-- 0</span>
: |     `<span class="comment">-- 0</span>
: `<span class="comment">-- 0</span>
:    |<span class="comment">-- 0</span>
:    |  |<span class="comment">-- 0</span>
:    |  `<span class="comment">-- 0</span>
:    `<span class="comment">-- 0</span>
:       |<span class="comment">-- 0</span>
:       `<span class="comment">-- 0</span>
</code></pre>

<p>打起精神,
我们再写个更有趣点的 tree:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">iTree</span> = <span class="label">Node</span> <span class="number">0</span> (dec iTree) (inc iTree)
        <span class="keyword">where</span>
           dec (<span class="label">Node</span> x l r) = <span class="label">Node</span> (x-<span class="number">1</span>) (dec l) (dec r)
           inc (<span class="label">Node</span> x l r) = <span class="label">Node</span> (x+<span class="number">1</span>) (inc l) (inc r)
</code></pre>


</div>
<p>另一种这样产生树的方法是用高阶函数.
函数会相似于 <code>map</code>, 但会作用于 <code>BinTree</code> 而不是 list.
下面是这样一个函数:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- apply a function to each node of Tree</span>
<span class="title">treeMap</span> :: (a -&gt; b) -&gt; <span class="label">BinTree</span> a -&gt; <span class="label">BinTree</span> b
<span class="title">treeMap</span> f <span class="label">Empty</span> = <span class="label">Empty</span>
<span class="title">treeMap</span> f (<span class="label">Node</span> x left right) = <span class="label">Node</span> (f x)
                                     (treeMap f left)
                                     (treeMap f right)
</code></pre>


</div>
<p><em>提示</em>: 关于这些我不会说太多.
如果你对生成其他数据结构的 <code>map</code> 感兴趣,
可以搜索 functor 和 <code>fmap</code>.</p>

<p>我们现在定义是:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">infTreeTwo</span> :: <span class="label">BinTree</span> <span class="label">Int</span>
<span class="title">infTreeTwo</span> = <span class="label">Node</span> <span class="number">0</span> (treeMap (\x -&gt; x-<span class="number">1</span>) infTreeTwo)
                    (treeMap (\x -&gt; x+<span class="number">1</span>) infTreeTwo)
</code></pre>


</div>
<p>看下它的结果</p>

<pre><code class="haskell"><span class="title">main</span> = print $ treeTakeDepth <span class="number">4</span> infTreeTwo
</code></pre>

<pre><code class="lua">&lt;  <span class="number">0</span>
: |<span class="comment">-- -1</span>
: |  |<span class="comment">-- -2</span>
: |  |  |<span class="comment">-- -3</span>
: |  |  `<span class="comment">-- -1</span>
: |  `<span class="comment">-- 0</span>
: |     |<span class="comment">-- -1</span>
: |     `<span class="comment">-- 1</span>
: `<span class="comment">-- 1</span>
:    |<span class="comment">-- 0</span>
:    |  |<span class="comment">-- -1</span>
:    |  `<span class="comment">-- 1</span>
:    `<span class="comment">-- 2</span>
:       |<span class="comment">-- 1</span>
:       `<span class="comment">-- 3</span>
</code></pre>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = <span class="keyword">do</span>
  print $ treeTakeDepth <span class="number">4</span> nullTree
  print $ treeTakeDepth <span class="number">4</span> infTreeTwo
</code></pre>


</div>
</div>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/41_Infinites_Structures.lhs" class="cut">02_Hard_Part/<strong>41_Infinites_Structures.lhs</strong> </a></p>

<h2 id="hell-difficulty-part">超难的地方</h2>

<p>祝贺你看了这么远!
现在一些真的难啃的东西可以开始了</p>

<p>如果你像我这样, 你应该已经懂函数式的风格了.
你应该也多懂了一点默认采用惰性计算的优势.
但你也还没弄明白怎么完成一个真正的程序.
其中特别是:</p>

<ul>
  <li>你怎么处理副作用?</li>
  <li>为什么还有一套命令式的写法的来处理 IO?</li>
</ul>

<p>准备一下, 答案可能比较复杂.
但是答案能带来很多的收获.</p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/01_IO/01_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>01_progressive_io_example.lhs</strong></a></p>

<h3 id="deal-with-io">处理 IO</h3>

<p><img alt="Magritte, Carte blanche" src="./Learn Haskell Fast and Hard_files/magritte_carte_blanche.jpg"></p>

<blockquote>
  <p><span class="sc"><abbr title="Too long; didn&#39;t read">tl;dr</abbr>: </span></p>

  <p>A typical function doing <code>IO</code> looks a lot like an imperative program:</p>

  <pre><code class="perl">f :: IO a
f = <span class="keyword">do</span>
  <span class="keyword">x</span> &lt;- action1
  action2 <span class="keyword">x</span>
  <span class="keyword">y</span> &lt;- action3
  action4 <span class="keyword">x</span> <span class="keyword">y</span>
</code></pre>

  <ul>
    <li>To set a value to an object we use <code>&lt;-</code> .</li>
    <li>The type of each line is <code>IO *</code>;
in this example:
      <ul>
        <li><code>action1     :: IO b</code></li>
        <li><code>action2 x   :: IO ()</code></li>
        <li><code>action3     :: IO c</code></li>
        <li><code>action4 x y :: IO a</code></li>
        <li><code>x :: b</code>, <code>y :: c</code></li>
      </ul>
    </li>
    <li>Few objects have the type <code>IO a</code>, this should help you choose.
In particular you cannot use pure functions directly here.
To use pure functions you could do <code>action2 (purefunction x)</code> for example.</li>
  </ul>
</blockquote>

<p>In this section, I will explain how to use IO, not how it works.
You’ll see how Haskell separates the pure from the impure parts of the program.</p>

<p>Don’t stop because you’re trying to understand the details of the syntax.
Answers will come in the next section.</p>

<p>What to achieve?</p>

<blockquote>
  <p>Ask a user to enter a list of numbers.
Print the sum of the numbers</p>
</blockquote>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">toList</span> :: <span class="label">String</span> -&gt; [<span class="label">Integer</span>]
<span class="title">toList</span> input = read (<span class="string">"["</span> ++ input ++ <span class="string">"]"</span>)

<span class="title">main</span> = <span class="keyword">do</span>
  putStrLn <span class="string">"Enter a list of numbers (separated by comma):"</span>
  input &lt;- getLine
  print $ sum (toList input)
</code></pre>


</div>
<p>It should be straightforward to understand the behavior of this program.
Let’s analyze the types in more detail.</p>

<pre><code class="haskell"><span class="title">putStrLn</span> :: <span class="label">String</span> -&gt; <span class="label">IO</span> ()
<span class="title">getLine</span>  :: <span class="label">IO</span> <span class="label">String</span>
<span class="title">print</span>    :: <span class="label">Show</span> a =&gt; a -&gt; <span class="label">IO</span> ()
</code></pre>

<p>Or more interestingly, we note that each expression in the <code>do</code> block has a type of <code>IO a</code>.</p>

<pre>main = do
  putStrLn "Enter ... " :: <span class="high">IO ()</span>
  getLine               :: <span class="high">IO String</span>
  print Something       :: <span class="high">IO ()</span>
</pre>

<p>We should also pay attention to the effect of the <code>&lt;-</code> symbol.</p>

<pre><code class="sql"><span class="operator"><span class="keyword">do</span>
 x &lt;- something
</span></code></pre>

<p>If <code>something :: IO a</code> then <code>x :: a</code>.</p>

<p>Another important note about using <code>IO</code>.
All lines in a do block must be of one of the two forms:</p>

<pre><code class="cs">action1             :: IO a
                    -- <span class="keyword">in</span> <span class="keyword">this</span> <span class="keyword">case</span>, generally a = ()
</code></pre>

<p>or</p>

<pre><code class="haskell"><span class="title">value</span> &lt;- action2    <span class="comment">-- where</span>
                    <span class="comment">-- bar z t :: IO b</span>
                    <span class="comment">-- value   :: b</span>
</code></pre>

<p>These two kinds of line will correspond to two different ways of sequencing actions.
The meaning of this sentence should be clearer by the end of the next section.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/01_IO/01_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>01_progressive_io_example.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/01_IO/02_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>02_progressive_io_example.lhs</strong></a></p>

<p>Now let’s see how this program behaves.
For example, what occur if the user enter something strange?
Let’s try:</p>

<pre><code class="coffeescript">    % runghc <span class="number">02</span>_progressive_io_example.lhs
    Enter a list <span class="keyword">of</span> numbers (separated <span class="keyword">by</span> comma):
    foo
    Prelude.read: <span class="literal">no</span> parse
</code></pre>

<p>Argh! An evil error message and a crash!
The first evolution will be to answer with a more friendly message.</p>

<p>In order to do this, we must detect that something went wrong.
Here is one way to do this.
Use the type <code>Maybe</code>.
It is a very common type in Haskell.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="import"><span class="keyword">import</span> Data.Maybe</span>
</code></pre>


</div>
<p>What is this thing? <code>Maybe</code> is a type which takes one parameter.
Its definition is:</p>

<pre><code class="haskell"><span class="class"><span class="keyword">data</span> <span class="label">Maybe</span> a = <span class="label">Nothing</span> | <span class="label">Just</span> a</span>
</code></pre>

<p>This is a nice way to tell there was an error while trying to create/compute
a value.
The <code>maybeRead</code> function is a great example of this.
This is a function similar to the function <code>read</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">5</a></sup>,
but if something goes wrong the returned value is <code>Nothing</code>.
If the value is right, it returns <code>Just &lt;the value&gt;</code>.
Don’t try to understand too much of this function.
I use a lower level function than <code>read</code>; <code>reads</code>.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">maybeRead</span> :: <span class="label">Read</span> a =&gt; <span class="label">String</span> -&gt; <span class="label">Maybe</span> a
<span class="title">maybeRead</span> s = <span class="keyword">case</span> reads s <span class="keyword">of</span>
                  [(x,<span class="string">""</span>)]    -&gt; <span class="label">Just</span> x
                  _           -&gt; <span class="label">Nothing</span>
</code></pre>


</div>
<p>Now to be a bit more readable, we define a function which goes like this:
If the string has the wrong format, it will return <code>Nothing</code>.
Otherwise, for example for “1,2,3”, it will return <code>Just [1,2,3]</code>.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">getListFromString</span> :: <span class="label">String</span> -&gt; <span class="label">Maybe</span> [<span class="label">Integer</span>]
<span class="title">getListFromString</span> str = maybeRead $ <span class="string">"["</span> ++ str ++ <span class="string">"]"</span>
</code></pre>


</div>
<p>We simply have to test the value in our main function.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> :: <span class="label">IO</span> ()
<span class="title">main</span> = <span class="keyword">do</span>
  putStrLn <span class="string">"Enter a list of numbers (separated by comma):"</span>
  input &lt;- getLine
  <span class="keyword">let</span> maybeList = getListFromString input <span class="keyword">in</span>
      <span class="keyword">case</span> maybeList <span class="keyword">of</span>
          <span class="label">Just</span> l  -&gt; print (sum l)
          <span class="label">Nothing</span> -&gt; error <span class="string">"Bad format. Good Bye."</span>
</code></pre>


</div>
<p>In case of error, we display a nice error message.</p>

<p>Note that the type of each expression in the main’s do block remains of the form <code>IO a</code>.
The only strange construction is <code>error</code>.
I’ll say <code>error msg</code> will simply take the needed type (here <code>IO ()</code>).</p>

<p>One very important thing to note is the type of all the functions defined so far.
There is only one function which contains <code>IO</code> in its type: <code>main</code>.
This means main is impure.
But main uses <code>getListFromString</code> which is pure.
It is then clear just by looking at declared types which functions are pure and
which are impure.</p>

<p>Why does purity matter?
I certainly forget many advantages, but the three main reasons are:</p>

<ul>
  <li>It is far easier to think about pure code than impure one.</li>
  <li>Purity protects you from all the hard to reproduce bugs due to side effects.</li>
  <li>You can evaluate pure functions in any order or in parallel without risk.</li>
</ul>

<p>This is why you should generally put as most code as possible inside pure functions.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/01_IO/02_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>02_progressive_io_example.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/01_IO/03_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>03_progressive_io_example.lhs</strong></a></p>

<p>Our next evolution will be to prompt the user again and again until she enters a valid answer.</p>

<p>We keep the first part:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="import"><span class="keyword">import</span> Data.Maybe</span>

<span class="title">maybeRead</span> :: <span class="label">Read</span> a =&gt; <span class="label">String</span> -&gt; <span class="label">Maybe</span> a
<span class="title">maybeRead</span> s = <span class="keyword">case</span> reads s <span class="keyword">of</span>
                  [(x,<span class="string">""</span>)]    -&gt; <span class="label">Just</span> x
                  _           -&gt; <span class="label">Nothing</span>
<span class="title">getListFromString</span> :: <span class="label">String</span> -&gt; <span class="label">Maybe</span> [<span class="label">Integer</span>]
<span class="title">getListFromString</span> str = maybeRead $ <span class="string">"["</span> ++ str ++ <span class="string">"]"</span>
</code></pre>


</div>
<p>Now, we create a function which will ask the user for an list of integers
until the input is right.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">askUser</span> :: <span class="label">IO</span> [<span class="label">Integer</span>]
<span class="title">askUser</span> = <span class="keyword">do</span>
  putStrLn <span class="string">"Enter a list of numbers (separated by comma):"</span>
  input &lt;- getLine
  <span class="keyword">let</span> maybeList = getListFromString input <span class="keyword">in</span>
      <span class="keyword">case</span> maybeList <span class="keyword">of</span>
          <span class="label">Just</span> l  -&gt; return l
          <span class="label">Nothing</span> -&gt; askUser
</code></pre>


</div>
<p>This function is of type <code>IO [Integer]</code>.
Such a type means that we retrieved a value of type <code>[Integer]</code> through some IO actions.
Some people might explain while waving their hands: </p>

<blockquote>
  <p>«This is an <code>[Integer]</code> inside an <code>IO</code>»</p>
</blockquote>

<p>If you want to understand the details behind all of this, you’ll have to read the next section.
But sincerely, if you just want to <em>use</em> IO.
Just practice a little and remember to think about the type.</p>

<p>Finally our main function is quite simpler:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> :: <span class="label">IO</span> ()
<span class="title">main</span> = <span class="keyword">do</span>
  list &lt;- askUser
  print $ sum list
</code></pre>


</div>
<p>We have finished with our introduction to <code>IO</code>.
This was quite fast. Here are the main things to remember:</p>

<ul>
  <li>in the <code>do</code> bloc, each expression must have the type <code>IO a</code>.
You are then limited in the number of expressions available.
For example, <code>getLine</code>, <code>print</code>, <code>putStrLn</code>, etc…</li>
  <li>Try to externalize the pure functions as much as possible.</li>
  <li>the <code>IO a</code> type means: an IO <em>action</em> which returns an element of type <code>a</code>.
<code>IO</code> represents actions; under the hood, <code>IO a</code> is the type of a function.
Read the next section if you are curious.</li>
</ul>

<p>If you practice a bit, you should be able to <em>use</em> <code>IO</code>.</p>

<blockquote>
  <p><em>Exercises</em>:</p>

  <ul>
    <li>Make a program that sums all of its arguments. Hint: use the function <code>getArgs</code>.</li>
  </ul>
</blockquote>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/01_IO/03_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>03_progressive_io_example.lhs</strong> </a></p>

<h3 id="io-trick-explained">IO 手法解析</h3>

<p><img alt="Magritte, ceci n&#39;est pas une pipe" src="./Learn Haskell Fast and Hard_files/magritte_pipe.jpg"></p>

<blockquote>
  <p>Here is a <span class="sc"><abbr title="Too long; didn&#39;t read">tl;dr</abbr>: </span> for this section.</p>

  <p>To separate pure and impure parts,
<code>main</code> is defined as a function
which modifies the state of the world</p>

  <pre><code class="haskell"><span class="title">main</span> :: <span class="label">World</span> -&gt; <span class="label">World</span>
</code></pre>

  <p>A function is guaranteed to have side effects only if it has this type.
But look at a typical main function:</p>

  <pre><code class="haskell"><span class="title">main</span> w0 =
    <span class="keyword">let</span> (v1,w1) = action1 w0 <span class="keyword">in</span>
    <span class="keyword">let</span> (v2,w2) = action2 v1 w1 <span class="keyword">in</span>
    <span class="keyword">let</span> (v3,w3) = action3 v2 w2 <span class="keyword">in</span>
    action4 v3 w3
</code></pre>

  <p>We have a lot of temporary elements (here <code>w1</code>, <code>w2</code> and <code>w3</code>)
which must be passed on to the next action.</p>

  <p>We create a function <code>bind</code> or <code>(&gt;&gt;=)</code>.
With <code>bind</code> we don’t need temporary names anymore.</p>

  <pre><code class="haskell"><span class="title">main</span> =
  action1 &gt;&gt;= action2 &gt;&gt;= action3 &gt;&gt;= action4
</code></pre>

  <p>Bonus: Haskell has syntactical sugar for us:</p>

  <pre><code class="haskell"><span class="title">main</span> = <span class="keyword">do</span>
  v1 &lt;- action1
  v2 &lt;- action2 v1
  v3 &lt;- action3 v2
  action4 v3
</code></pre>
</blockquote>

<p>Why did we use this strange syntax, and what exactly is this <code>IO</code> type?
It looks a bit like magic.</p>

<p>For now let’s just forget all about the pure parts of our program, and focus
on the impure parts:</p>

<pre><code class="haskell"><span class="title">askUser</span> :: <span class="label">IO</span> [<span class="label">Integer</span>]
<span class="title">askUser</span> = <span class="keyword">do</span>
  putStrLn <span class="string">"Enter a list of numbers (separated by commas):"</span>
  input &lt;- getLine
  <span class="keyword">let</span> maybeList = getListFromString input <span class="keyword">in</span>
      <span class="keyword">case</span> maybeList <span class="keyword">of</span>
          <span class="label">Just</span> l  -&gt; return l
          <span class="label">Nothing</span> -&gt; askUser

<span class="title">main</span> :: <span class="label">IO</span> ()
<span class="title">main</span> = <span class="keyword">do</span>
  list &lt;- askUser
  print $ sum list
</code></pre>

<p>First remark; it looks like an imperative structure.
Haskell is powerful enough to make impure code look imperative.
For example, if you wish you could create a <code>while</code> in Haskell.
In fact, for dealing with <code>IO</code>, imperative style is generally more appropriate.</p>

<p>But you should had noticed the notation is a bit unusual.
Here is why, in detail.</p>

<p>In an impure language, the state of the world can be seen as a huge hidden global variable.
This hidden variable is accessible by all functions of your language.
For example, you can read and write a file in any function.
The fact that a file exists or not can be seen as different states of the world.</p>

<p>For Haskell this state is not hidden.
It is explicitly said <code>main</code> is a function that <em>potentially</em> changes the state of the world.
Its type is then something like:</p>

<pre><code class="haskell"><span class="title">main</span> :: <span class="label">World</span> -&gt; <span class="label">World</span>
</code></pre>

<p>Not all functions may have access to this variable.
Those which have access to this variable are impure.
Functions to which the world variable isn’t provided are pure<sup id="fnref:032001"><a href="#fn:032001" rel="footnote">6</a></sup>.</p>

<p>Haskell considers the state of the world as an input variable to <code>main</code>.
But the real type of main is closer to this one<sup id="fnref:032002"><a href="#fn:032002" rel="footnote">7</a></sup>:</p>

<pre><code class="haskell"><span class="title">main</span> :: <span class="label">World</span> -&gt; ((),<span class="label">World</span>)
</code></pre>

<p>The <code>()</code> type is the null type.
Nothing to see here.</p>

<p>Now let’s rewrite our main function with this in mind:</p>

<pre><code class="haskell"><span class="title">main</span> w0 =
    <span class="keyword">let</span> (list,w1) = askUser w0 <span class="keyword">in</span>
    <span class="keyword">let</span> (x,w2) = print (sum list,w1) <span class="keyword">in</span>
    x
</code></pre>

<p>First, we note that all functions which have side effects must have the type:</p>

<pre><code class="haskell"><span class="label">World</span> -&gt; (a,<span class="label">World</span>)
</code></pre>

<p>Where <code>a</code> is the type of the result.
For example, a <code>getChar</code> function should have the type <code>World -&gt; (Char,World)</code>.</p>

<p>Another thing to note is the trick to fix the order of evaluation.
In Haskell, in order to evaluate <code>f a b</code>, you have many choices:</p>

<ul>
  <li>first eval <code>a</code> then <code>b</code> then <code>f a b</code></li>
  <li>first eval <code>b</code> then <code>a</code> then <code>f a b</code>.</li>
  <li>eval <code>a</code> and <code>b</code> in parallel then <code>f a b</code></li>
</ul>

<p>This is true, because we should work in a pure language.</p>

<p>Now, if you look at the main function, it is clear you must eval the first
line before the second one since, to evaluate the second line you have
to get a parameter given by the evaluation of the first line.</p>

<p>Such trick works nicely.
The compiler will at each step provide a pointer to a new real world id.
Under the hood, <code>print</code> will evaluate as:</p>

<ul>
  <li>print something on the screen</li>
  <li>modify the id of the world</li>
  <li>evaluate as <code>((),new world id)</code>.</li>
</ul>

<p>Now, if you look at the style of the main function, it is clearly awkward.
Let’s try to do the same to the askUser function:</p>

<pre><code class="haskell"><span class="title">askUser</span> :: <span class="label">World</span> -&gt; ([<span class="label">Integer</span>],<span class="label">World</span>)
</code></pre>

<p>Before:</p>

<pre><code class="haskell"><span class="title">askUser</span> :: <span class="label">IO</span> [<span class="label">Integer</span>]
<span class="title">askUser</span> = <span class="keyword">do</span>
  putStrLn <span class="string">"Enter a list of numbers:"</span>
  input &lt;- getLine
  <span class="keyword">let</span> maybeList = getListFromString input <span class="keyword">in</span>
      <span class="keyword">case</span> maybeList <span class="keyword">of</span>
          <span class="label">Just</span> l  -&gt; return l
          <span class="label">Nothing</span> -&gt; askUser
</code></pre>

<p>After:</p>

<pre><code class="haskell"><span class="title">askUser</span> w0 =
    <span class="keyword">let</span> (_,w1)     = putStrLn <span class="string">"Enter a list of numbers:"</span> <span class="keyword">in</span>
    <span class="keyword">let</span> (input,w2) = getLine w1 <span class="keyword">in</span>
    <span class="keyword">let</span> (l,w3)     = <span class="keyword">case</span> getListFromString input <span class="keyword">of</span>
                      <span class="label">Just</span> l   -&gt; (l,w2)
                      <span class="label">Nothing</span>  -&gt; askUser w2
    <span class="keyword">in</span>
        (l,w3)
</code></pre>

<p>This is similar, but awkward.
Look at all these temporary <code>w?</code> names.</p>

<p>The lesson, is, naive IO implementation in Pure functional languages is awkward!</p>

<p>Fortunately, there is a better way to handle this problem.
We see a pattern.
Each line is of the form:</p>

<pre><code class="haskell"><span class="title">let</span> (y,w') = action x w <span class="keyword">in</span>
</code></pre>

<p>Even if for some line the first <code>x</code> argument isn’t needed.
The output type is a couple, <code>(answer, newWorldValue)</code>.
Each function <code>f</code> must have a type similar to:</p>

<pre><code class="haskell"><span class="title">f</span> :: <span class="label">World</span> -&gt; (a,<span class="label">World</span>)
</code></pre>

<p>Not only this, but we can also note that we always follow the same usage pattern:</p>

<pre><code class="haskell"><span class="title">let</span> (y,w1) = action1 w0 <span class="keyword">in</span>
<span class="title">let</span> (z,w2) = action2 w1 <span class="keyword">in</span>
<span class="title">let</span> (t,w3) = action3 w2 <span class="keyword">in</span>
...
</code></pre>

<p>Each action can take from 0 to n parameters.
And in particular, each action can take a parameter from the result of a line above.</p>

<p>For example, we could also have:</p>

<pre><code class="haskell"><span class="title">let</span> (_,w1) = action1 x w0   <span class="keyword">in</span>
<span class="title">let</span> (z,w2) = action2 w1     <span class="keyword">in</span>
<span class="title">let</span> (_,w3) = action3 x z w2 <span class="keyword">in</span>
...
</code></pre>

<p>And of course <code>actionN w :: (World) -&gt; (a,World)</code>.</p>

<blockquote>
  <p>IMPORTANT, there are only two important patterns to consider:</p>

  <pre><code class="avrasm">let (<span class="built_in">x</span>,w1) = action1 w0 <span class="keyword">in</span>
let (<span class="built_in">y</span>,w2) = action2 <span class="built_in">x</span> w1 <span class="keyword">in</span>
</code></pre>

  <p>and</p>

  <pre><code class="cs"><span class="keyword">let</span> (_,w1) = action1 w0 <span class="keyword">in</span>
<span class="keyword">let</span> (y,w2) = action2 w1 <span class="keyword">in</span>
</code></pre>
</blockquote>

<p><img alt="Jocker pencil trick" src="./Learn Haskell Fast and Hard_files/jocker_pencil_trick.jpg" class=" left"></p>

<p>Now, we will do a magic trick.
We will make the temporary world symbol “disappear”.
We will <code>bind</code> the two lines.
Let’s define the <code>bind</code> function.
Its type is quite intimidating at first:</p>

<pre><code class="haskell"><span class="title">bind</span> :: (<span class="label">World</span> -&gt; (a,<span class="label">World</span>))
        -&gt; (a -&gt; (<span class="label">World</span> -&gt; (b,<span class="label">World</span>)))
        -&gt; (<span class="label">World</span> -&gt; (b,<span class="label">World</span>))
</code></pre>

<p>But remember that <code>(World -&gt; (a,World))</code> is the type for an IO action.
Now let’s rename it for clarity:</p>

<pre><code class="haskell"><span class="class"><span class="keyword">type</span> <span class="label">IO</span> a = <span class="label">World</span> -&gt; (a, <span class="label">World</span>)</span>
</code></pre>

<p>Some example of functions:</p>

<pre><code class="haskell"><span class="title">getLine</span> :: <span class="label">IO</span> <span class="label">String</span>
<span class="title">print</span> :: <span class="label">Show</span> a =&gt; a -&gt; <span class="label">IO</span> ()
</code></pre>

<p><code>getLine</code> is an IO action which takes a world as parameter and returns a couple <code>(String,World)</code>.
Which can be summarized as: <code>getLine</code> is of type <code>IO String</code>.
Which we also see as, an IO action which will return a String “embeded inside an IO”.</p>

<p>The function <code>print</code> is also interesting.
It takes one argument which can be shown.
In fact it takes two arguments.
The first is the value to print and the other is the state of world.
It then returns a couple of type <code>((),World)</code>.
This means it changes the state of the world, but doesn’t yield anymore data.</p>

<p>This type helps us simplify the type of <code>bind</code>:</p>

<pre><code class="haskell"><span class="title">bind</span> :: <span class="label">IO</span> a
        -&gt; (a -&gt; <span class="label">IO</span> b)
        -&gt; <span class="label">IO</span> b
</code></pre>

<p>It says that <code>bind</code> takes two IO actions as parameter and return another IO action.</p>

<p>Now, remember the <em>important</em> patterns. The first was:</p>

<pre><code class="haskell"><span class="title">let</span> (x,w1) = action1 w0 <span class="keyword">in</span>
<span class="title">let</span> (y,w2) = action2 x w1 <span class="keyword">in</span>
(y,w2)
</code></pre>

<p>Look at the types:</p>

<pre><code class="haskell"><span class="title">action1</span>  :: <span class="label">IO</span> a
<span class="title">action2</span>  :: a -&gt; <span class="label">IO</span> b
(y,w2)   :: <span class="label">IO</span> b
</code></pre>

<p>Doesn’t it seem familiar?</p>

<pre><code class="haskell">(bind action1 action2) w0 =
    <span class="keyword">let</span> (x, w1) = action1 w0
        (y, w2) = action2 x w1
    <span class="keyword">in</span>  (y, w2)
</code></pre>

<p>The idea is to hide the World argument with this function. Let’s go:
As an example imagine if we wanted to simulate:</p>

<pre><code class="haskell"><span class="title">let</span> (line1,w1) = getLine w0 <span class="keyword">in</span>
<span class="title">let</span> ((),w2) = print line1 <span class="keyword">in</span>
((),w2)
</code></pre>

<p>Now, using the bind function:</p>

<pre><code class="haskell">(res,w2) = (bind getLine (\l -&gt; print l)) w0
</code></pre>

<p>As print is of type (World → ((),World)), we know res = () (null type).
If you didn’t see what was magic here, let’s try with three lines this time.</p>

<pre><code class="haskell"><span class="title">let</span> (line1,w1) = getLine w0 <span class="keyword">in</span>
<span class="title">let</span> (line2,w2) = getLine w1 <span class="keyword">in</span>
<span class="title">let</span> ((),w3) = print (line1 ++ line2) <span class="keyword">in</span>
((),w3)
</code></pre>

<p>Which is equivalent to:</p>

<pre><code class="haskell">(res,w3) = bind getLine (\line1 -&gt;
             bind getLine (\line2 -&gt;
               print (line1 ++ line2)))
</code></pre>

<p>Didn’t you notice something?
Yes, no temporary World variables are used anywhere!
This is <em>MA</em>. <em>GIC</em>.</p>

<p>We can use a better notation.
Let’s use <code>(&gt;&gt;=)</code> instead of <code>bind</code>.
<code>(&gt;&gt;=)</code> is an infix function like
<code>(+)</code>; reminder <code>3 + 4 ⇔ (+) 3 4</code></p>

<pre><code class="haskell">(res,w3) = getLine &gt;&gt;=
           \line1 -&gt; getLine &gt;&gt;=
           \line2 -&gt; print (line1 ++ line2)
</code></pre>

<p>Ho Ho Ho! Happy Christmas Everyone!
Haskell has made syntactical sugar for us:</p>

<pre><code class="haskell"><span class="title">do</span>
  x &lt;- action1
  y &lt;- action2
  z &lt;- action3
  ...
</code></pre>

<p>Is replaced by:</p>

<pre><code class="haskell"><span class="title">action1</span> &gt;&gt;= \x -&gt;
<span class="title">action2</span> &gt;&gt;= \y -&gt;
<span class="title">action3</span> &gt;&gt;= \z -&gt;
...
</code></pre>

<p>Note you can use <code>x</code> in <code>action2</code> and <code>x</code> and <code>y</code> in <code>action3</code>.</p>

<p>But what about the lines not using the <code>&lt;-</code>?
Easy, another function <code>blindBind</code>:</p>

<pre><code class="haskell"><span class="title">blindBind</span> :: <span class="label">IO</span> a -&gt; <span class="label">IO</span> b -&gt; <span class="label">IO</span> b
<span class="title">blindBind</span> action1 action2 w0 =
    bind action (\_ -&gt; action2) w0
</code></pre>

<p>I didn’t simplify this definition for clarity purpose.
Of course we can use a better notation, we’ll use the <code>(&gt;&gt;)</code> operator.</p>

<p>And</p>

<pre><code class="haskell"><span class="title">do</span>
    action1
    action2
    action3
</code></pre>

<p>Is transformed into</p>

<pre><code class="haskell"><span class="title">action1</span> &gt;&gt;
<span class="title">action2</span> &gt;&gt;
<span class="title">action3</span>
</code></pre>

<p>Also, another function is quite useful.</p>

<pre><code class="haskell"><span class="title">putInIO</span> :: a -&gt; <span class="label">IO</span> a
<span class="title">putInIO</span> x = <span class="label">IO</span> (\w -&gt; (x,w))
</code></pre>

<p>This is the general way to put pure values inside the “IO context”.
The general name for <code>putInIO</code> is <code>return</code>.
This is quite a bad name when you learn Haskell. <code>return</code> is very different from what you might be used to. </p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/01_IO/21_Detailled_IO.lhs" class="cut">03_Hell/01_IO/<strong>21_Detailled_IO.lhs</strong></a></p>

<p>To finish, let’s translate our example:</p>

<pre><code class="haskell">
<span class="title">askUser</span> :: <span class="label">IO</span> [<span class="label">Integer</span>]
<span class="title">askUser</span> = <span class="keyword">do</span>
  putStrLn <span class="string">"Enter a list of numbers (separated by commas):"</span>
  input &lt;- getLine
  <span class="keyword">let</span> maybeList = getListFromString input <span class="keyword">in</span>
      <span class="keyword">case</span> maybeList <span class="keyword">of</span>
          <span class="label">Just</span> l  -&gt; return l
          <span class="label">Nothing</span> -&gt; askUser

<span class="title">main</span> :: <span class="label">IO</span> ()
<span class="title">main</span> = <span class="keyword">do</span>
  list &lt;- askUser
  print $ sum list
</code></pre>

<p>Is translated into:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="import"><span class="keyword">import</span> Data.Maybe</span>

<span class="title">maybeRead</span> :: <span class="label">Read</span> a =&gt; <span class="label">String</span> -&gt; <span class="label">Maybe</span> a
<span class="title">maybeRead</span> s = <span class="keyword">case</span> reads s <span class="keyword">of</span>
                  [(x,<span class="string">""</span>)]    -&gt; <span class="label">Just</span> x
                  _           -&gt; <span class="label">Nothing</span>
<span class="title">getListFromString</span> :: <span class="label">String</span> -&gt; <span class="label">Maybe</span> [<span class="label">Integer</span>]
<span class="title">getListFromString</span> str = maybeRead $ <span class="string">"["</span> ++ str ++ <span class="string">"]"</span>
<span class="title">askUser</span> :: <span class="label">IO</span> [<span class="label">Integer</span>]
<span class="title">askUser</span> =
    putStrLn <span class="string">"Enter a list of numbers (sep. by commas):"</span> &gt;&gt;
    getLine &gt;&gt;= \input -&gt;
    <span class="keyword">let</span> maybeList = getListFromString input <span class="keyword">in</span>
      <span class="keyword">case</span> maybeList <span class="keyword">of</span>
        <span class="label">Just</span> l -&gt; return l
        <span class="label">Nothing</span> -&gt; askUser

<span class="title">main</span> :: <span class="label">IO</span> ()
<span class="title">main</span> = askUser &gt;&gt;=
  \list -&gt; print $ sum list
</code></pre>


</div>
<p>You can compile this code to verify it keeps working.</p>

<p>Imagine what it would look like without the <code>(&gt;&gt;)</code> and <code>(&gt;&gt;=)</code>.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/01_IO/21_Detailled_IO.lhs" class="cut">03_Hell/01_IO/<strong>21_Detailled_IO.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/02_Monads/10_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>10_Monads.lhs</strong></a></p>

<h3 id="monads">Monads</h3>

<p><img alt="Dali, reve. It represents a weapon out of the mouth of a tiger, itself out of the mouth of another tiger, itself out of the mouth of a fish itself out of a grenade. I could have choosen a picture of the Human centipede as it is a very good representation of what a monad really is. But just to thing about it, I find this disgusting and that wasn&#39;t the purpose of this document." src="./Learn Haskell Fast and Hard_files/dali_reve.jpg"></p>

<p>Now the secret can be revealed: <code>IO</code> is a <em>monad</em>.
Being a monad means you have access to some syntactical sugar with the <code>do</code> notation.
But mainly, you have access to a coding pattern which will ease the flow of your code.</p>

<blockquote>
  <p><strong>Important remarks</strong>:</p>

  <ul>
    <li>Monad are not necessarily about effects!
There are a lot of <em>pure</em> monads.</li>
    <li>Monad are more about sequencing</li>
  </ul>
</blockquote>

<p>For the Haskell language <code>Monad</code> is a type class.
To be an instance of this type class, you must provide the functions <code>(&gt;&gt;=)</code> and <code>return</code>.
The function <code>(&gt;&gt;)</code> will be derived from <code>(&gt;&gt;=)</code>.
Here is how the type class <code>Monad</code> is declared (mostly):</p>

<pre><code class="haskell"><span class="class"><span class="keyword">class</span> <span class="label">Monad</span> m  <span class="keyword">where</span></span>
  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
  return :: a -&gt; m a

  (&gt;&gt;) :: m a -&gt; m b -&gt; m b
  f &gt;&gt; g = f &gt;&gt;= \_ -&gt; g

  <span class="comment">-- You should generally safely ignore this function</span>
  <span class="comment">-- which I believe exists for historical reason</span>
  fail :: <span class="label">String</span> -&gt; m a
  fail = error
</code></pre>

<blockquote>
  <p>Remarks:</p>

  <ul>
    <li>the keyword <code>class</code> is not your friend.
A Haskell class is <em>not</em> a class like in object model.
A Haskell class has a lot of similarities with Java interfaces.
A better word should have been <code>typeclass</code>.
That means a set of types.
For a type to belong to a class, all functions of the class must be provided for this type.</li>
    <li>In this particular example of type class, the type <code>m</code> must be a type that takes an argument.
for example <code>IO a</code>, but also <code>Maybe a</code>, <code>[a]</code>, etc…</li>
    <li>
      <p>To be a useful monad, your function must obey some rules.
If your construction does not obey these rules strange things might happens:</p>

      <pre><code class="tex">return a &gt;&gt;= k  ==  k a
m &gt;&gt;= return  ==  m
m &gt;&gt;= (<span class="command">\x</span> -&gt; k x &gt;&gt;= h)  ==  (m &gt;&gt;= k) &gt;&gt;= h
</code></pre>
    </li>
  </ul>
</blockquote>

<h4 id="maybe-monad">Maybe 是 monad</h4>

<p>There are a lot of different types that are instance of <code>Monad</code>.
One of the easiest to describe is <code>Maybe</code>.
If you have a sequence of <code>Maybe</code> values, you can use monads to manipulate them.
It is particularly useful to remove very deep <code>if..then..else..</code> constructions.</p>

<p>Imagine a complex bank operation. You are eligible to gain about 700€ only
if you can afford to follow a list of operations without being negative.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">deposit</span>  value account = account + value
<span class="title">withdraw</span> value account = account - value

<span class="title">eligible</span> :: (<span class="label">Num</span> a,<span class="label">Ord</span> a) =&gt; a -&gt; <span class="label">Bool</span>
<span class="title">eligible</span> account =
  <span class="keyword">let</span> account1 = deposit <span class="number">100</span> account <span class="keyword">in</span>
    <span class="keyword">if</span> (account1 &lt; <span class="number">0</span>)
    <span class="keyword">then</span> <span class="label">False</span>
    <span class="keyword">else</span>
      <span class="keyword">let</span> account2 = withdraw <span class="number">200</span> account1 <span class="keyword">in</span>
      <span class="keyword">if</span> (account2 &lt; <span class="number">0</span>)
      <span class="keyword">then</span> <span class="label">False</span>
      <span class="keyword">else</span>
        <span class="keyword">let</span> account3 = deposit <span class="number">100</span> account2 <span class="keyword">in</span>
        <span class="keyword">if</span> (account3 &lt; <span class="number">0</span>)
        <span class="keyword">then</span> <span class="label">False</span>
        <span class="keyword">else</span>
          <span class="keyword">let</span> account4 = withdraw <span class="number">300</span> account3 <span class="keyword">in</span>
          <span class="keyword">if</span> (account4 &lt; <span class="number">0</span>)
          <span class="keyword">then</span> <span class="label">False</span>
          <span class="keyword">else</span>
            <span class="keyword">let</span> account5 = deposit <span class="number">1000</span> account4 <span class="keyword">in</span>
            <span class="keyword">if</span> (account5 &lt; <span class="number">0</span>)
            <span class="keyword">then</span> <span class="label">False</span>
            <span class="keyword">else</span>
              <span class="label">True</span>

<span class="title">main</span> = <span class="keyword">do</span>
  print $ eligible <span class="number">300</span> <span class="comment">-- True</span>
  print $ eligible <span class="number">299</span> <span class="comment">-- False</span>
</code></pre>


</div>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/02_Monads/10_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>10_Monads.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/02_Monads/11_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>11_Monads.lhs</strong></a></p>

<p>Now, let’s make it better using Maybe and the fact that it is a Monad</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">deposit</span> :: (<span class="label">Num</span> a) =&gt; a -&gt; a -&gt; <span class="label">Maybe</span> a
<span class="title">deposit</span> value account = <span class="label">Just</span> (account + value)

<span class="title">withdraw</span> :: (<span class="label">Num</span> a,<span class="label">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="label">Maybe</span> a
<span class="title">withdraw</span> value account = <span class="keyword">if</span> (account &lt; value)
                         <span class="keyword">then</span> <span class="label">Nothing</span>
                         <span class="keyword">else</span> <span class="label">Just</span> (account - value)

<span class="title">eligible</span> :: (<span class="label">Num</span> a, <span class="label">Ord</span> a) =&gt; a -&gt; <span class="label">Maybe</span> <span class="label">Bool</span>
<span class="title">eligible</span> account = <span class="keyword">do</span>
  account1 &lt;- deposit <span class="number">100</span> account
  account2 &lt;- withdraw <span class="number">200</span> account1
  account3 &lt;- deposit <span class="number">100</span> account2
  account4 &lt;- withdraw <span class="number">300</span> account3
  account5 &lt;- deposit <span class="number">1000</span> account4
  <span class="label">Just</span> <span class="label">True</span>

<span class="title">main</span> = <span class="keyword">do</span>
  print $ eligible <span class="number">300</span> <span class="comment">-- Just True</span>
  print $ eligible <span class="number">299</span> <span class="comment">-- Nothing</span>
</code></pre>


</div>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/02_Monads/11_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>11_Monads.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/02_Monads/12_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>12_Monads.lhs</strong></a></p>

<p>Not bad, but we can make it even better:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">deposit</span> :: (<span class="label">Num</span> a) =&gt; a -&gt; a -&gt; <span class="label">Maybe</span> a
<span class="title">deposit</span> value account = <span class="label">Just</span> (account + value)

<span class="title">withdraw</span> :: (<span class="label">Num</span> a,<span class="label">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="label">Maybe</span> a
<span class="title">withdraw</span> value account = <span class="keyword">if</span> (account &lt; value)
                         <span class="keyword">then</span> <span class="label">Nothing</span>
                         <span class="keyword">else</span> <span class="label">Just</span> (account - value)

<span class="title">eligible</span> :: (<span class="label">Num</span> a, <span class="label">Ord</span> a) =&gt; a -&gt; <span class="label">Maybe</span> <span class="label">Bool</span>
<span class="title">eligible</span> account =
  deposit <span class="number">100</span> account &gt;&gt;=
  withdraw <span class="number">200</span> &gt;&gt;=
  deposit <span class="number">100</span>  &gt;&gt;=
  withdraw <span class="number">300</span> &gt;&gt;=
  deposit <span class="number">1000</span> &gt;&gt;
  return <span class="label">True</span>

<span class="title">main</span> = <span class="keyword">do</span>
  print $ eligible <span class="number">300</span> <span class="comment">-- Just True</span>
  print $ eligible <span class="number">299</span> <span class="comment">-- Nothing</span>
</code></pre>


</div>
<p>We have proven that Monads are a good way to make our code more elegant.
Note this idea of code organization, in particular for <code>Maybe</code> can be used
in most imperative language.
In fact, this is the kind of construction we make naturally.</p>

<blockquote>
  <p>An important remark:</p>

  <p>The first element in the sequence being evaluated to <code>Nothing</code> will stop
the complete evaluation.
This means you don’t execute all lines.
You have this for free, thanks to laziness.</p>
</blockquote>

<p>The <code>Maybe</code> monad proved to be useful while being a very simple example.
We saw the utility of the <code>IO</code> monad.
But now a cooler example, lists.</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/02_Monads/12_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>12_Monads.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/02_Monads/13_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>13_Monads.lhs</strong></a></p>

<h4 id="the-list-monad">List monad</h4>

<p><img alt="Golconde de Magritte" src="./Learn Haskell Fast and Hard_files/golconde.jpg"></p>

<p>The list monad helps us to simulate non deterministic computations.
Here we go:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="import"><span class="keyword">import</span> Control.Monad <span class="container">(<span class="title">guard</span>)</span></span>

<span class="title">allCases</span> = [<span class="number">1.</span>.<span class="number">10</span>]

<span class="title">resolve</span> :: [(<span class="label">Int</span>,<span class="label">Int</span>,<span class="label">Int</span>)]
<span class="title">resolve</span> = <span class="keyword">do</span>
              x &lt;- allCases
              y &lt;- allCases
              z &lt;- allCases
              guard $ <span class="number">4</span>*x + <span class="number">2</span>*y &lt; z
              return (x,y,z)

<span class="title">main</span> = <span class="keyword">do</span>
  print resolve
</code></pre>


</div>
<p>MA. GIC.&nbsp;:</p>

<pre><code class="css"><span class="attr_selector">[(1,1,7),(1,1,8),(1,1,9),(1,1,10),(1,2,9),(1,2,10)]</span>
</code></pre>

<p>For the list monad, there is also a syntactical sugar:</p>

<div class="codehighlight">


<pre><code class="haskell">  print $ [ (x,y,z) |&nbsp;x &lt;- allCases,
                      y &lt;- allCases,
                      z &lt;- allCases,
                      <span class="number">4</span>*x + <span class="number">2</span>*y &lt; z ]
</code></pre>


</div>
<p>I won’t list all the monads, but there are many monads.
Using monads simplifies the manipulation of several notions in pure languages.
In particular, monad are very useful for: </p>

<ul>
  <li>IO,</li>
  <li>non deterministic computation,</li>
  <li>generating pseudo random numbers, </li>
  <li>keeping configuration state, </li>
  <li>writing state,</li>
  <li>…</li>
</ul>

<p>If you have followed me until here, then you’ve done it!
You know monads<sup id="fnref:03021301"><a href="#fn:03021301" rel="footnote">8</a></sup>!</p>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/03_Hell/02_Monads/13_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>13_Monads.lhs</strong> </a></p>

<h2 id="appendix">附录</h2>

<p>This section is not so much about learning Haskell.
It is just here to discuss some details further.</p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/04_Appendice/01_More_on_infinite_trees/10_Infinite_Trees.lhs" class="cut">04_Appendice/01_More_on_infinite_trees/<strong>10_Infinite_Trees.lhs</strong></a></p>

<h3 id="more-on-infinite-tree">更多关于 Infinite Tree</h3>

<p>In the section <a href="#infinite-structures">Infinite Structures</a> we saw some simple
constructions.
Unfortunately we removed two properties from our tree:</p>

<ol>
  <li>no duplicate node value</li>
  <li>well ordered tree</li>
</ol>

<p>In this section we will try to keep the first property.
Concerning the second one, we must relax it but we’ll discuss how to
keep it as much as possible.</p>

<div style="display:none">

This code is mostly the same as the one in the [tree section](#trees).

<div class="codehighlight">


<pre><code class="haskell"><span class="import"><span class="keyword">import</span> Data.List</span>
<span class="class"><span class="keyword">data</span> <span class="label">BinTree</span> a = <span class="label">Empty</span> </span>
                 | <span class="label">Node</span> a (<span class="label">BinTree</span> a) (<span class="label">BinTree</span> a)
                  <span class="keyword">deriving</span> (<span class="label">Eq</span>,<span class="label">Ord</span>)

<span class="comment">-- declare BinTree a to be an instance of Show</span>
<span class="class"><span class="keyword">instance</span> (<span class="label">Show</span> a) =&gt; <span class="label">Show</span> (<span class="label">BinTree</span> a) <span class="keyword">where</span></span>
  <span class="comment">-- will start by a '&lt;' before the root</span>
  <span class="comment">-- and put a : a begining of line</span>
  show t = <span class="string">"&lt; "</span> ++ replace<span class="string"> '\n'</span> <span class="string">"\n: "</span> (treeshow <span class="string">""</span> t)
    <span class="keyword">where</span>
    treeshow pref <span class="label">Empty</span> = <span class="string">""</span>
    treeshow pref (<span class="label">Node</span> x <span class="label">Empty</span> <span class="label">Empty</span>) =
                  (pshow pref x)

    treeshow pref (<span class="label">Node</span> x left <span class="label">Empty</span>) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> left)

    treeshow pref (<span class="label">Node</span> x <span class="label">Empty</span> right) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> right)

    treeshow pref (<span class="label">Node</span> x left right) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"|--"</span> <span class="string">"|  "</span> left) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> right)

    <span class="comment">-- show a tree using some prefixes to make it nice</span>
    showSon pref before next t =
                  pref ++ before ++ treeshow (pref ++ next) t

    <span class="comment">-- pshow replace "\n" by "\n"++pref</span>
    pshow pref x = replace<span class="string"> '\n'</span> (<span class="string">"\n"</span>++pref) (show x)

    <span class="comment">-- replace on char by another string</span>
    replace c new string =
      concatMap (change c new) string
      <span class="keyword">where</span>
          change c new x
              | x == c = new
              | otherwise = x:[] <span class="comment">-- "x"</span>

</code></pre>


</div>
</div>

<p>Our first step is to create some pseudo-random number list:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">shuffle</span> = map (\x -&gt; (x*<span class="number">3123</span>) `mod` <span class="number">4331</span>) [<span class="number">1.</span>.]
</code></pre>


</div>
<p>Just as a reminder, here is the definition of <code>treeFromList</code></p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">treeFromList</span> :: (<span class="label">Ord</span> a) =&gt; [a] -&gt; <span class="label">BinTree</span> a
<span class="title">treeFromList</span> []    = <span class="label">Empty</span>
<span class="title">treeFromList</span> (x:xs) = <span class="label">Node</span> x (treeFromList (filter (&lt;x) xs))
                             (treeFromList (filter (&gt;x) xs))
</code></pre>


</div>
<p>and <code>treeTakeDepth</code>:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">treeTakeDepth</span> _ <span class="label">Empty</span> = <span class="label">Empty</span>
<span class="title">treeTakeDepth</span> <span class="number">0</span> _     = <span class="label">Empty</span>
<span class="title">treeTakeDepth</span> n (<span class="label">Node</span> x left right) = <span class="keyword">let</span>
          nl = treeTakeDepth (n-<span class="number">1</span>) left
          nr = treeTakeDepth (n-<span class="number">1</span>) right
          <span class="keyword">in</span>
              <span class="label">Node</span> x nl nr
</code></pre>


</div>
<p>See the result of:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = <span class="keyword">do</span>
      putStrLn <span class="string">"take 10 shuffle"</span>
      print $ take <span class="number">10</span> shuffle
      putStrLn <span class="string">"\ntreeTakeDepth 4 (treeFromList shuffle)"</span>
      print $ treeTakeDepth <span class="number">4</span> (treeFromList shuffle)
</code></pre>


</div>
<pre><code class="haskell">% runghc <span class="number">02</span>_Hard_Part/<span class="number">41</span>_Infinites_Structures.lhs
<span class="title">take</span> <span class="number">10</span> shuffle
[<span class="number">3123</span>,<span class="number">1915</span>,<span class="number">707</span>,<span class="number">3830</span>,<span class="number">2622</span>,<span class="number">1414</span>,<span class="number">206</span>,<span class="number">3329</span>,<span class="number">2121</span>,<span class="number">913</span>]
<span class="title">treeTakeDepth</span> <span class="number">4</span> (treeFromList shuffle)

&lt; <span class="number">3123</span>
: |<span class="comment">--1915</span>
: |  |<span class="comment">--707</span>
: |  |  |<span class="comment">--206</span>
: |  |  `<span class="comment">--1414</span>
: |  `<span class="comment">--2622</span>
: |     |<span class="comment">--2121</span>
: |     `<span class="comment">--2828</span>
: `<span class="comment">--3830</span>
:    |<span class="comment">--3329</span>
:    |  |<span class="comment">--3240</span>
:    |  `<span class="comment">--3535</span>
:    `<span class="comment">--4036</span>
:       |<span class="comment">--3947</span>
:       `<span class="comment">--4242</span>
</code></pre>

<p>Yay! It ends!
Beware though, it will only work if you always have something to put into a branch.</p>

<p>For example </p>

<pre><code class="haskell"><span class="title">treeTakeDepth</span> <span class="number">4</span> (treeFromList [<span class="number">1.</span>.])
</code></pre>

<p>will loop forever.
Simply because it will try to access the head of <code>filter (&lt;1) [2..]</code>.
But <code>filter</code> is not smart enought to understand that the result is the empty list.</p>

<p>Nonetheless, it is still a very cool example of what non strict programs have to offer.</p>

<p>Left as an exercise to the reader:</p>

<ul>
  <li>Prove the existence of a number <code>n</code> so that <code>treeTakeDepth n (treeFromList shuffle)</code> will enter an infinite loop.</li>
  <li>Find an upper bound for <code>n</code>.</li>
  <li>Prove there is no <code>shuffle</code> list so that, for any depth, the program ends.</li>
</ul>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/04_Appendice/01_More_on_infinite_trees/10_Infinite_Trees.lhs" class="cut">04_Appendice/01_More_on_infinite_trees/<strong>10_Infinite_Trees.lhs</strong> </a></p>

<hr>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/04_Appendice/01_More_on_infinite_trees/11_Infinite_Trees.lhs" class="cut">04_Appendice/01_More_on_infinite_trees/<strong>11_Infinite_Trees.lhs</strong></a></p>

<div style="display:none">

This code is mostly the same as the preceding one.

<div class="codehighlight">


<pre><code class="haskell"><span class="import"><span class="keyword">import</span> Debug.Trace <span class="container">(<span class="title">trace</span>)</span></span>
<span class="import"><span class="keyword">import</span> Data.List</span>
<span class="class"><span class="keyword">data</span> <span class="label">BinTree</span> a = <span class="label">Empty</span> </span>
                 | <span class="label">Node</span> a (<span class="label">BinTree</span> a) (<span class="label">BinTree</span> a)
                  <span class="keyword">deriving</span> (<span class="label">Eq</span>,<span class="label">Ord</span>)
</code></pre>


</div>
<div class="codehighlight">


<pre><code class="haskell"><span class="comment">-- declare BinTree a to be an instance of Show</span>
<span class="class"><span class="keyword">instance</span> (<span class="label">Show</span> a) =&gt; <span class="label">Show</span> (<span class="label">BinTree</span> a) <span class="keyword">where</span></span>
  <span class="comment">-- will start by a '&lt;' before the root</span>
  <span class="comment">-- and put a : a begining of line</span>
  show t = <span class="string">"&lt; "</span> ++ replace<span class="string"> '\n'</span> <span class="string">"\n: "</span> (treeshow <span class="string">""</span> t)
    <span class="keyword">where</span>
    treeshow pref <span class="label">Empty</span> = <span class="string">""</span>
    treeshow pref (<span class="label">Node</span> x <span class="label">Empty</span> <span class="label">Empty</span>) =
                  (pshow pref x)

    treeshow pref (<span class="label">Node</span> x left <span class="label">Empty</span>) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> left)

    treeshow pref (<span class="label">Node</span> x <span class="label">Empty</span> right) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> right)

    treeshow pref (<span class="label">Node</span> x left right) =
                  (pshow pref x) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"|--"</span> <span class="string">"|  "</span> left) ++ <span class="string">"\n"</span> ++
                  (showSon pref <span class="string">"`--"</span> <span class="string">"   "</span> right)

    <span class="comment">-- show a tree using some prefixes to make it nice</span>
    showSon pref before next t =
                  pref ++ before ++ treeshow (pref ++ next) t

    <span class="comment">-- pshow replace "\n" by "\n"++pref</span>
    pshow pref x = replace<span class="string"> '\n'</span> (<span class="string">"\n"</span>++pref) (<span class="string">" "</span> ++ show x)

    <span class="comment">-- replace on char by another string</span>
    replace c new string =
      concatMap (change c new) string
      <span class="keyword">where</span>
          change c new x
              | x == c = new
              | otherwise = x:[] <span class="comment">-- "x"</span>

<span class="title">treeTakeDepth</span> _ <span class="label">Empty</span> = <span class="label">Empty</span>
<span class="title">treeTakeDepth</span> <span class="number">0</span> _     = <span class="label">Empty</span>
<span class="title">treeTakeDepth</span> n (<span class="label">Node</span> x left right) = <span class="keyword">let</span>
          nl = treeTakeDepth (n-<span class="number">1</span>) left
          nr = treeTakeDepth (n-<span class="number">1</span>) right
          <span class="keyword">in</span>
              <span class="label">Node</span> x nl nr
</code></pre>


</div>
</div>

<p>In order to resolve these problem we will modify slightly our
<code>treeFromList</code> and <code>shuffle</code> function.</p>

<p>A first problem, is the lack of infinite different number in our implementation of <code>shuffle</code>.
We generated only <code>4331</code> different numbers.
To resolve this we make a slightly better <code>shuffle</code> function.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">shuffle</span> = map rand [<span class="number">1.</span>.]
          <span class="keyword">where</span>
              rand x = ((p x) `mod` (x+c)) - ((x+c) `div` <span class="number">2</span>)
              p x = m*x^<span class="number">2</span> + n*x + o <span class="comment">-- some polynome</span>
              m = <span class="number">3123</span>
              n = <span class="number">31</span>
              o = <span class="number">7641</span>
              c = <span class="number">1237</span>
</code></pre>


</div>
<p>This shuffle function has the property (hopefully) not to have an upper nor lower bound.
But having a better shuffle list isn’t enough not to enter an infinite loop.</p>

<p>Generally, we cannot decide whether <code>filter (&lt;x) xs</code> is empty.
Then to resolve this problem, I’ll authorize some error in the creation of our binary tree.
This new version of code can create binary tree which don’t have the following property for some of its nodes: </p>

<blockquote>
  <p>Any element of the left (resp. right) branch must all be strictly inferior (resp. superior) to the label of the root.</p>
</blockquote>

<p>Remark it will remains <em>mostly</em> an ordered binary tree.
Furthermore, by construction, each node value is unique in the tree.</p>

<p>Here is our new version of <code>treeFromList</code>. We simply have replaced <code>filter</code> by <code>safefilter</code>.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">treeFromList</span> :: (<span class="label">Ord</span> a, <span class="label">Show</span> a) =&gt; [a] -&gt; <span class="label">BinTree</span> a
<span class="title">treeFromList</span> []    = <span class="label">Empty</span>
<span class="title">treeFromList</span> (x:xs) = <span class="label">Node</span> x left right
          <span class="keyword">where</span>
              left = treeFromList $ safefilter (&lt;x) xs
              right = treeFromList $ safefilter (&gt;x) xs
</code></pre>


</div>
<p>This new function <code>safefilter</code> is almost equivalent to <code>filter</code> but don’t enter infinite loop if the result is a finite list.
If it cannot find an element for which the test is true after 10000 consecutive steps, then it considers to be the end of the search.</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">safefilter</span> :: (a -&gt; <span class="label">Bool</span>) -&gt; [a] -&gt; [a]
<span class="title">safefilter</span> f l = safefilter' f l nbTry
  <span class="keyword">where</span>
      nbTry = <span class="number">10000</span>
      safefilter' _ _ <span class="number">0</span> = []
      safefilter' _ [] _ = []
      safefilter' f (x:xs) n =
                  <span class="keyword">if</span> f x
                     <span class="keyword">then</span> x : safefilter' f xs nbTry
                     <span class="keyword">else</span> safefilter' f xs (n-<span class="number">1</span>)
</code></pre>


</div>
<p>Now run the program and be happy:</p>

<div class="codehighlight">


<pre><code class="haskell"><span class="title">main</span> = <span class="keyword">do</span>
      putStrLn <span class="string">"take 10 shuffle"</span>
      print $ take <span class="number">10</span> shuffle
      putStrLn <span class="string">"\ntreeTakeDepth 8 (treeFromList shuffle)"</span>
      print $ treeTakeDepth <span class="number">8</span> (treeFromList $ shuffle)
</code></pre>


</div>
<p>You should realize the time to print each value is different.
This is because Haskell compute each value when it needs it.
And in this case, this is when asked to print it on the screen.</p>

<p>Impressively enough, try to replace the depth from <code>8</code> to <code>100</code>.
It will work without killing your RAM!
The flow and the memory management is done naturally by Haskell.</p>

<p>Left as an exercise to the reader:</p>

<ul>
  <li>Even with large constant value for <code>deep</code> and <code>nbTry</code>, it seems to work nicely. But in the worst case, it can be exponential.
Create a worst case list to give as parameter to <code>treeFromList</code>.<br>
<em>hint</em>: think about (<code>[0,-1,-1,....,-1,1,-1,...,-1,1,...]</code>).</li>
  <li>I first tried to implement <code>safefilter</code> as follow:
    <pre>safefilter' f l = if filter f (take 10000 l) == []
                  then []
                  else filter f l
</pre>
    <p>Explain why it doesn’t work and can enter into an infinite loop.</p>
  </li>
  <li>Suppose that <code>shuffle</code> is real random list with growing bounds.
If you study a bit this structure, you’ll discover that with probability 1,
this structure is finite.
Using the following code
(suppose we could use <code>safefilter'</code> directly as if was not in the where of safefilter)
find a definition of <code>f</code> such that with probability <code>1</code>,
treeFromList’ shuffle is infinite. And prove it.
Disclaimer, this is only a conjecture.</li>
</ul>

<pre><code class="haskell"><span class="title">treeFromList'</span> []  n = <span class="label">Empty</span>
<span class="title">treeFromList'</span> (x:xs) n = <span class="label">Node</span> x left right
    <span class="keyword">where</span>
        left = treeFromList' (safefilter' (&lt;x) xs (f n)
        right = treeFromList' (safefilter' (&gt;x) xs (f n)
        f = ???
</code></pre>

<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/04_Appendice/01_More_on_infinite_trees/11_Infinite_Trees.lhs" class="cut">04_Appendice/01_More_on_infinite_trees/<strong>11_Infinite_Trees.lhs</strong> </a></p>

<h2 id="thanks">Thanks</h2>

<p>Thanks to <a href="http://reddit.com/r/haskell"><code>/r/haskell</code></a> and
<a href="http://reddit.com/r/programming"><code>/r/programming</code></a>.
Your comment were most than welcome.</p>

<p>Particularly, I want to thank <a href="https://github.com/Emm">Emm</a> a thousand times
for the time he spent on correcting my English.
Thank you man.</p>
<hr><div class="footnotes">
  <ol>
    <li id="fn:0001">
      <p>Even if most recent languages try to hide them, they are present.<a href="#fnref:0001" rel="reference">↩</a></p>
    </li>
    <li id="fn:2">
      <p>I know I’m cheating. But I will talk about non-strict later.<a href="#fnref:2" rel="reference">↩</a></p>
    </li>
    <li id="fn:021301">
      <p>For the brave, a more complete explanation of pattern matching can be found <a href="http://www.cs.auckland.ac.nz/references/haskell/haskell-intro-html/patterns.html">here</a>.<a href="#fnref:021301" rel="reference">↩</a></p>
    </li>
    <li id="fn:0216">
      <p>You should remark <code>squareEvenSum''</code> is more efficient that the two other versions. The order of <code>(.)</code> is important.<a href="#fnref:0216" rel="reference">↩</a></p>
    </li>
    <li id="fn:1">
      <p>Which itself is very similar to the javascript <code>eval</code> on a string containing JSON).<a href="#fnref:1" rel="reference">↩</a></p>
    </li>
    <li id="fn:032001">
      <p>There are some <em>unsafe</em> exceptions to this rule. But you shouldn’t see such use on a real application except maybe for debugging purpose.<a href="#fnref:032001" rel="reference">↩</a></p>
    </li>
    <li id="fn:032002">
      <p>For the curious the real type is <code>data IO a = IO {unIO :: State# RealWorld -&gt; (# State# RealWorld, a #)}</code>. All the <code>#</code> as to do with optimisation and I swapped the fields in my example. But mostly, the idea is exactly the same.<a href="#fnref:032002" rel="reference">↩</a></p>
    </li>
    <li id="fn:03021301">
      <p>Well, you’ll certainly need to practice a bit to get used to them and to understand when you can use them and create your own. But you already made a big step in this direction.<a href="#fnref:03021301" rel="reference">↩</a></p>
    </li>
  </ol>
</div>
                </div>
                <div id="social">
                    <div class="left">
     </div>
                    <div class="left"> <div class="g-plusone" data-size="medium" data-annotation="inline" data-width="106"></div>
     </div>
                    <div class="flush"></div>
                </div>
                <div id="entete" class="corps_spaced">
                    <div id="liens">
                        <ul><li><a href="http://yannesposito.com/Scratch/en/">Home</a></li>
<li><a href="http://yannesposito.com/Scratch/en/blog/">Blog</a></li>
<li><a href="http://yannesposito.com/Scratch/en/softwares/">Softwares</a></li>
<li><a href="http://yannesposito.com/Scratch/en/about/">About</a></li></ul>
                    </div>
                    <div class="flush"></div>
                    <hr>
                    <div id="next_before_articles">
                        <div id="previous_articles">
                            previous entries
                            <div class="previous_article">
                                <a href="http://yannesposito.com/Scratch/en/blog/Typography-and-the-Web/"><span class="nicer">«</span>&nbsp;Typography and the Web</a>
                            </div>
                            <div class="previous_article">
                                <a href="http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/"><span class="nicer">«</span>&nbsp;Haskell web programming</a>
                            </div>
                            <div class="previous_article">
                                <a href="http://yannesposito.com/Scratch/en/blog/SVG-and-m4-fractals/"><span class="nicer">«</span>&nbsp;Increase the power of deficient languages.</a>
                            </div>
                        </div>
                        <div id="next_articles">
                            next entries

                            <div class="next_article">
                                <a href="http://yannesposito.com/Scratch/en/blog/Haskell-OpenGL-Mandelbrot/">Haskell Progressive Example&nbsp;<span class="nicer">»</span></a>
                            </div>
                        </div>
                        <div class="flush"></div>
                    </div>
                </div>
                <div id="bottom">
                    <div>
                        <a href="https://twitter.com/yogsototh">Follow @yogsototh</a>
                    </div>
                    <div>
                        <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Copyright ©, Yann Esposito</a>
                    </div>
                    <div id="lastmod">
                        Created: 02/08/2012
                        Modified: 06/05/2012
                    </div>
                    <div>
                        Entirely done with
                        <a href="http://www.vim.org/">Vim</a>
                        and
                        <a href="http://nanoc.stoneship.org/">nanoc</a>
                    </div>
                </div>
                <div class="clear"></div>
            </div>
        </div>
</body></html>
